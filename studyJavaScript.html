<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 공부</title>
    <style>
        bold {font-size: 25px; font-weight: bold;}
        span {display: block; margin: 20px 0;}
    </style>
</head>
<body>
    <span>▶ 기본 영역</span>
    <span>알림 출력 : alert('알림');</span>
    <span>콘솔 출력 : console.log('콘솔');</span>
    <span>값 입력받기 : prompt('아무 값이나 입력해주세요!');</span>
    <span>Html 파일에 글 추가 : documnet.write("아무 문자");</span>
    <span>형변환 (숫자 → 문자) : String(3); //맨앞이 대문자</span>

    <hr>

    <span><bold>숫자 및 문자열 영역</bold></span>
    <span>수의 연산 :<br>
        Math.pow(3,2);       //출력 : 9,   3의 2승<br>
        Math.round(10.6);    //출력 : 11,  10.6을 반올림<br>
        Math.ceil(10.2);     //출력 : 11,  10.2를 올림<br>
        Math.floor(10.6);    //출력 : 10,  10.6을 내림<br>
        Math.sqrt(9);        //출력 : 3,   3의 제곱근<br>
        Math.random();       //출력 : 0부터 1.0 사이의 랜덤한 숫자 (소수점 포함)<br>
        Math.round(100*Math.random()+1);       //출력 : 1부터 100 사이의 랜덤한 숫자 (정수)
    </span>
    <span>자료형 확인 : alert(typeof [변수명 또는 숫자 또는 문자열]); //출력 예시 : string 또는 number</span>
    <span>문자열 더하기 : alert("Hello"+" World"); //출력 : Hello World</span>
    <span>문자열 길이 : "Hello World".length//출력 : 11</span>
    <span>문자 위치 구하기 : "code".indexof("c"); //출력 : 0</span>

    <hr>

    <span><bold>변수 영역</bold></span>
    <span>변수 선언 : <br>
        var f="te"; var b="st"; 또는 var f="te", b="st";<br>
        사용 => alert(f+b); //출력 : test<br><br>
    </span>
    <span>변수 입력 받기 : <br>
        var name=prompt('당신의 이름은 무엇인가요?');//test 입력
        alert(name);    //출력 : test
    </span>

    <hr>

    <span><bold>연산자 영역</bold></span>
    <span>== 연산자 사용 (값만 같으면 됨) : <br>
        alert(1 == 2)             //출력 : false<br>
        alert(1 == 1)             //출력 : true<br><br>
        alert("one" == "two")     //출력 : false<br>
        alert("one" == "one")     //출력 : true
    </span>
    <span>=== 연산자 사용 (조건을 엄격하게 하여 비교 => 값과 자료형이 모두 같아야 됨) : <br>
        alert(1 == '1');          //출력 : true<br>
        alert(1 === '1');         //출력 : false<br><br>
        alert(null == undefined); //출력 : true<br>
        alert(null === undefined);//출력 : false<br><br>
        alert(true == 1);         //출력 : true<br>
        alert(true === 1);        //출력 : false<br>
        alert(true == '1');       //출력 : true<br>
        alert(true === '1');      //출력 : false<br><br>
        alert(0 === -0);          //출력 : true<br>
        alert(NaN === NaN);       //출력 : false<br>
    </span>
    <span>같지 않음을 비교하는 ==와 ===처럼 같지 않음을 비교하는 !=와 !==가 존재한다.<br>
        alert(1 != '1');          //출력 : false<br>
        alert(1 !== '1');         //출력 : true
    </span>
    <span>And를 의미하는 &&와 Or을 의미하는 ||가 있다.</span>

    <hr>

    <span><bold>조건문 영역</bold></span>
    <span>
        <pre>
        if(true){
            alert('result : true');
        }

        if(false){
            alert('result : true');
        }

        if(조건1){
            alert('if 결과');
        }
        else if(조건2){
            alert('else if 결과');
        }
        else {
            alert('else 결과');
        }

        switch ( condition ) {
            case value1:
              statement1;
              break;
            case value2:
              statement2;
              break;
            ...
            default:
              statement3;
          }

          //예시
          var test="test";
          switch ( test ) {
            case "test":
              console.log("test입니다.");
              break;
            case "notTest":
              console.log("notTest입니다.");
              break;
            case "whyTest":
              console.log("whyTest입니다.");
              break;
            default:
              console.log("default입니다.");
              break;
          }
          //출력 : test입니다.
        </pre>
    </span>
    <span>true나 false 대신에 1과 0을 쓸 수는 있지만 ==와 ===같은 것을 보면 실전에서는 그냥 true나 false를 쓰는 것이 낫다.</span>
    <span>조건에 변수명을 넣으면 만약 해당 변수가 비어있지 않다면 true를 비어있다면 false를 반환한다.</span>

    <hr>

    <span><bold>반복문 영역</bold></span>
    <span>
        <pre>
            for(초기화; 반복조건; 반복이 될 때마다 실행되는 코드){
                반복할 문장;
            }
            
            //예시
            for(var i = 0; i < 10; i++){
                document.write(i+' ');
            }

            while(조건)}{
                반복할 문장;
            }

            //예시
            var i = 0;
            while(i < 10){
                document.write(i+' ');
                i++;
            }

            //무한 반복
            while(ture){
                반복할 문장;
            }

            //반복 제어 - 반복 중지
            for(var i = 0; i < 10; i++){
                if(i===5){break;}//반복을 중지시키고 for문을 빠져나온다.

                document.write(i+' ');
            }

            //반복 제어 - 넘기기
            for(var i = 0; i < 10; i++){
                if(i===5){continue;}//i가 5일 때 반복을 한번 생략하고 다음 반복 (i가 6인 경우)을 진행한다.

                document.write(i+' ');
            }
        </pre>
    </span>

    <hr>

    <span><bold>함수 영역</bold></span>
    <span>함수 : 하나의 로직을 재실행할 수 있도록 하는 것</span>
    <span>함수의 특징 : <br>
        1. 코드의 재사용성을 높여준다.
        2. 유지보수가 용이하다.
        3. 가독성이 올라간다.
    </span>
    <span>
        <pre>
            < 선언 방법 1 >
            function 함수명(인자1, 인자2, ...){
                코드 내용;
                return 반환값;  //필요시 선언
            }

            < 선언 방법 2 >
            var 함수명 = function()(인자1, 인자2, ...){{
                코드 내용;
                return 반환값;  //필요시 선언
            }}

            < 함수 실행 방법 >
            함수명(인자 존재시 인자 개수만큼 선언);

            < 선언 방법 3 > - 함수 선언과 동시에 실행하는 방법 ( = 익명 함수 ), function의 앞뒤로 ()를 써 준다.
            (function()(인자1, 인자2, ...){{
                코드 내용;
                return 반환값;  //필요시 선언
            }})();
        </pre>
    </span>

    <hr>

    <span><bold>배열 영역</bold></span>
    <span>배열 (Array) : 연관된 데이터를 모아서 한꺼번에 관리하기 위해서 사용하는 데이터 타입</span>
    <span>선언 방법 1 (배열 선언과 동시에 초기화): 
        <pre>
          var test = ['test0', 'test1', 'test2']; //대괄호를 사용한다.<br>
          이 때 test를 출력하면 모든 요소를 콤마(,)로 구분하여 보여준다.<br>
          alert(test); //출력 : test0,test1,test2
        </pre>
    </span>
    <span>선언 방법 2 (배열 선언과 동시에 초기화): 
        <pre>
          var test = new Array('test0', 'test1', 'test2'); //소괄호를 사용한다.<br>
          이 때 test를 출력하면 모든 요소를 콤마(,)로 구분하여 보여준다.<br>
          alert(test); //출력 : test0,test1,test2
        </pre>
    </span>
    <span>선언 방법 3 (배열만 선언하는 방법): 
        <pre>
          var test = new Array(3);
        </pre>
    </span>
    <span>사용 방법 : 위의 test에서 'test0' 출력 => alert(test[0]);</span>
    <span>배열의 길이 : 변수명.length</span>
    <span>데이터 추가 방법 1 :<br>
        <pre>
          위의 test의 데이터의 개수가 3개이기 때문에 test[3]="test3";를 하게 되면<br>
          test는  ['test0', 'test1', 'test2', 'test3']가 된다.
          대신 이 경우에는 배열이 갖고 있는 데이터의 개수를 알고 있어야 한다.
        </pre>
    </span>
    <span>데이터 추가 방법 2 (배열의 맨 뒤에 요소를 추가): <br>
        <pre>
          위의 test라는 배열의 맨 뒤에 데이터를 추가하고 싶을 때에는 test.push("test3");를 하면 된다.<br>
          하지만 이 경우에는 배열이 갖고 있는 데이터의 개수를 알고 있지 않아도 된다.
        </pre>
    </span>
    <span>데이터 추가 방법 3 (배열의 맨 앞에 요소를 추가): <br>
        <pre>
          위의 test라는 배열의 맨 앞에 데이터를 추가하고 싶을 때에는 test.unshift("test-1");를 하면 된다.<br>
          하지만 이 경우에는 배열이 갖고 있는 데이터의 개수를 알고 있지 않아도 된다.
        </pre>
    </span>
    <span>데이터 추가 방법 4 (배열의 중간에 요소를 추가): <br>
          <pre>
          위의 test라는 배열의 중간에 데이터를 추가하고 싶을 때에는 test.splice(index, count, element...);를 하면 된다.<br>
          만약 test에서 2번째에 요소를 3개 추가하고 싶다면 test.splice(2, 0, 'test-s-1', 'test-s-2', 'test-s-3');가 된다.<br>
          실행하면 test는 ["test0", "test1", "test-s-1", "test-s-2", "test-s-3", "test2"]가 된다.<br>
          
          이 때 splice의 인자에서 index는 요소가 추가되기 시작할 번호를 의미한다.<br>
          여기서 index는 말 그대로 index기 때문에 2번째라는게 1,2번째의 2번째가 아니라 배열의 0,1,2의 2번째다.<br>
          count는 index로부터 삭제될 요소의 개수를 의미한다. 만약 0을 선언하면 아무 것도 삭제하지 않고 추가한다.<br>
          
          만약 test.splice(2, 1, 'test-s-1', 'test-s-2', 'test-s-3');를 하면 test는 ["test0", "test1", "test-s-1", "test-s-2", "test-s-3"]가 된다.<br>
          이 때 test.splice의 count 인자를 통해 삭제된 인자는 실제로 사용 가능한 값이다.<br>
          그래서 만약 alert(test.splice(2, 1, 'test-s-1', 'test-s-2', 'test-s-3'));를 하면 삭제되는 값들이 출력된다.<br>
          삭제되는 요소가 2개 이상이면 콤마(,)를 통해 연결되서 출력된다.
        </pre>
    </span>
    <span>데이터 추가 방법 5 (배열 합치기): <br>
        <pre>
          위의 test라는 배열말고 추가로 example이라는 배열이 있다고 가정해보자.<br>
          만약 example이 ['example0','example1','example2']라고 했을 때<br>
          test에 example의 요소를 합치고 싶을때는 어떻할까?<br>

          바로 concat이라는 함수를 이용하면 된다.<br>

          test=test.concat(example); 또는 test=test.concat(['example0','example1','example2']);처럼 사용한다.<br>
          그러면 test에 test의 뒤에 example의 요소들을 붙인 배열이 되어 저장된다. (결과 : ["test0", "test1", "test2", "example0", "example1", "example2"])<br>
        </pre>  
    </span>
    <span>데이터 삭제 방법 1 (배열의 맨 뒤의 요소를 삭제) :<br>
        <pre>
          위의 test라는 배열에서 데이터를 삭제하고 싶을 때에는 test.pop();를 하면 된다.<br>
          그러면 배열에서 가장 마지막에 추가된 요소부터 차례대로 삭제된다.<br>

          또한 다른 특징으로 변수명.pop()을 해서 요소를 삭제하면 단순하게 삭제만 되는 것이 아니라 실제로 삭제된 값을 사용할 수 있다.<br>
          
          만약 test가 ['test0', 'test1', 'test2', 'test3']인 상태라고 가정하면<br>
          alert(test.pop());을 실행했을 때 알림으로 test3을 출력한 다음, test에서는 마지막 요소인 'test3'를 삭제하게 되고,<br>
          test는 ['test0', 'test1', 'test2']가 된다.
        </pre>
    </span>
    <span>데이터 삭제 방법 2 (배열의 맨 앞의 요소를 삭제) :<br>
        <pre>
          위의 test라는 배열에서 데이터를 삭제하고 싶을 때에는 test.shift();를 하면 된다.<br>
          그러면 배열에서 가장 처음에 추가된 요소부터 차례대로 삭제된다.<br>

          또한 다른 특징으로 변수명.shift()을 해서 요소를 삭제하면 단순하게 삭제만 되는 것이 아니라 실제로 삭제된 값을 사용할 수 있다.<br>
          
          만약 test가 ['test0', 'test1', 'test2', 'test3']인 상태라고 가정하면<br>
          alert(test.pop());을 실행했을 때 알림으로 test0을 출력한 다음, test에서는 마지막 요소인 'test0'를 삭제하게 되고,<br>
          test는 ['test1', 'test2', 'test3']이 된다.
        </pre>
    </span>
    <span>데이터 정렬 방법 :<br>
        <pre>
          만약 정렬이 되있지 않은 상태의 배열 변수인 sortTest가 있다고 하자.<br>
          sortTest가 ['b', 'c', 'a']라고 했을 때,

          sortTest를 오름차순으로 정렬하려면 sortTest.sort()를 하면 된다.;<br>
          그러면 sortTest는 ["a", "b", "c"]가 된다.<br>

          sortTest를 내림차순으로 정렬하려면 sortTest.reverse()를 하면 된다.;<br>
          그러면 sortTest는 ["c", "b", "a"]가 된다.<br>
        </pre>
    </span>
    <span>데이터 추출 방법 :<br>
        <pre>
            test가 ['test0', 'test1', 'test2' 'test3', 'test4']라고 가정했을 때<br>
            test.slice(start, end)를 하면 배열의 일부를 추출할 수있다. 단, 실제 배열의 값을 수정하진 않는다.<br>
            여기서 주의할 점은 이 때 추출되는 배열은 start에서 end까지가 아니라 start부터 end 사이의 값을 추출한다.<br>

            만약 test.slice(1,3);을 하게 되면 index 번호가 1에서 3까지인 'test1', 'test2' 'test3'이 아니라<br>
            1부터 3 사이인 'test1', 'test2'를 출력하게 된다.<br>
            역순인 test.slice(3,1);은 작동하지 않는다.

            또한 end를 생략하게 되면 start부터 배열의 마지막 요소까지의 모든 요소를 출력한다.<br>
            test.slice(1);을 하게 되면 'test1', 'test2' 'test3', 'test4'가 된다.

            그리고 인자를 -로 주게 되면 배열의 마지막부터 그 개수에 해당하는 요소를 출력한다.<br>
            test.slice(-2);를 하게 되면 'test3', 'test4'를 출력한다.
        </pre>
    </span>
    <span>데이터 합치기 방법 :<br>
        <pre>
            만약 내용물이 ['Hello', 'World', '...?']인 joinTest라는 배열이 있다고 가정했을 때<br>
            이 요소들을 하나의 문자열로 만들고 싶다면 join(text);를 사용하면 된다.<br>
            alert(joinTest.join(' '));을 하게 되면 'Hello World ...?'가 출력된다.<br>

            단순하게 alert(joinTest)를 하게 되면 각 요소들이 콤마(,)를 통해 합쳐져서 나오지만<br>
            join은 안의 인자인 test에 특정 문자열을 넣어서 해당 문자열로 콤마(,)를 대체해서 출력되게 한다.
        </pre>
    </span>
    
    <hr>
    
    <span><bold>객체 영역</bold></span>
    <span>
        객체 : index 번호로 요소를 꺼내오던 배열과 다르게<br>
        key 값이라는 문자열을 통하여 값을 꺼내오는 연관된 데이터들을 한꺼번에 관리하기 위해 사용하는 데이터형
    </span>
    <span>객체 생성 방법 1 (선언한 후에 초기화) :
        <pre>
            예시 : var grade = {};     //중괄호를 사용한다.
            grade['a']=1; grade['b']=2; grade['c']=3; //대괄호 안에 키 값을 표현한 후 값을 대입한다.
        </pre>
    </span>
    <span>객체 생성 방법 2 (선언과 동시에 초기화) :
        <pre>
            예시 : var grade = {'a' : 1, 'b' : 2, 'c' : 3};     //중괄호를 사용한다.
        </pre>
    </span>
    <span>객체 사용 방법 (단순 사용)
        <pre>
            alert(grade['a']);  //출력 : 1
        </pre>
    </span>
    <span>객체 사용 방법 (for문 사용 - 타 언어의 forEach 방식)
        <pre>
            var forEachTest = {'a' : 1, 'b' : 2, 'c' : 3};
            for(keyName in forEachTest) {
                console.log("keyName : "+keyName+" value : "+forEachTest[keyName]+"<br />");
            }
            
            keyName은 객체의 key 값을 처음부터 마지막까지 차례대로 읽어온다 (keyName은 직접 지정한 별칭, 자유지정 가능).
            forEachTest에는 내가 for문으로 읽어들일 객체의 실제 이름을 명시하면 된다.
        </pre>
    </span>
    <span>객체 지향 프로그래밍
        <pre>
            객체에는 배열이나 함수도 선언할 수 있다.

            var studentInfo={
                'grade' : {'bule' : 1, 'yellow' : 2, 'red' : 3},
                'class' : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                'functionTest' : function(){
                    for(var name in this.grade){
                        console.log('name : ' + name + ', value : ' + this.grade[name] + "\n")
                    }
                }
            };

            접근 방식 1 => 만약 grade의 bule에 접근하고 싶으면 studentInfo['grade']['blue']를 하면 된다.
            접근 방식 2 => 만약 class의 3번 인덱스에 접근하고 싶으면 studentInfo['class'][3]을 하면 된다.
            접근 방식 3 => 만약 객체의 내부에서 특정 키 값에 접근하고 싶다면 this.KEY이름을 하면 된다.
            접근 방식 4 => 만약 객체의 내부에 선언한 함수를 사용하고 싶다면
                           위의 경우에는 studentInfo.functionTest();를 하거나, studentInfo['functionTest']();를 하면 된다.
        </pre>
    </span>

    <hr>

    <span><bold>모듈 영역</bold></span>
    <span>모듈화 : 하나의 코드를 여러 개의 파일로 분리하는 작업<br>
        <pre>
            1. 자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 재활용이 가능하다.
            2. 코드를 개선하면 이를 사용하는 모든 애플리케이션의 동작이 개선된다.
            3. 코드 수정 시에 필요한 로직을 빠르게 찾을수 있다. 
            4. 필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다. 
            5. 한 번 다운로드 된 모듈은 웹 브라우저에 의해서 저장되기 때문에 동일한 로직을 로드 할 때
               시간과 네트워크 트래픽을 절약할 수 있다. (브라우저에서만 해당) 
        </pre>
    </span>
    <span>모듈화 방법 (기본) : <br>
        <pre>
            만약 index.html의 script 태그 안에
            function returnHelloWorld(){
                return "Hello World";
            }
            alert(returnHelloWorld());
            라는 기본적인 javascript 코드가 있다고 치자,

            지금은 매우 기본적인 짧고 간단한 코드지만 코드의 양이 많아지게 된다면 코드의 활용성과 가독성이 떨어지게 된다.
            
            그렇기 때문에 returnFunction.js같은 연관되 있는 기능들을 한 곳에 모아둘수 있는 특정 파일을 새로 만들어서
            그 파일에 따로 선언해둔 다음에 index.html에 와서 script 태그의 src 속성으로 returnFunction.js를 연결해서 사용한다.

            그렇게 되면 returnFunction.js에는 연관된 기능들끼리만 모여있기 때문에 편리성과 재활용성과 가독성이 좋아지게 되며
            이 경우에서의 index.html의 script 코드에는 alert(returnHelloWorld());만 남기 때문에 코드가 매우 간결해지는 효과를 얻게 된다. 
        </pre>
    </span>
    
    <hr>

    <span><bold>정규 표현식 영역</bold></span>
    <span>정규 표현식 : 문자열에서 특정한 문자를 찾아내는 도구</span>
    <span>정규 표현식을 사용하기 위한 편의성을 제공해주는 사이트 목록 :
        <pre>
            1. https://regexper.com/ : 정규 표현식을 시각화해서 보여주는 사이트
            2. http://gskinner.com/RegExr/ : 정규 표현식을 실시간으로 테스트해볼 수 있는 사이트
            3. http://www.regexr.com/ : 정규 표현식에 대한 도움말과 테스트 도구들을 제공하는 사이트 
        </pre>
    </span>
    <span>정규 표현식 생성 방법의 종류 :
        <pre>
            1. 컴파일 : 검출하고자 하는 패턴을 만드는 단계, 정규 표현식 객체를 만들어야 한다.
            2. 실행 : 컴파일 단계에서 만든 정규 표현식 객체를 통해서 특정 문자열을 검출하는 단계
        </pre>
    </span>
    <span>정규 표현식 - 컴파일 단계 :
        <pre>
            방법은 두 가지가 있으며, 두 가지 모두 같은 결과를 만들지만 각자가 가진 장단점이 다르다.

            ▶ 정규 표현식 리터럴
                var pattern = /찾을 문자/;
            ▶ 정규 표현식 객체 생성자
                var pattern = new RegExp('찾을 문자');
            ▶ 정규 표현식의 특수 기호
                . : 문자 한 자리를 의미한다.
        </pre>
    </span>
    <span>정규 표현식 - 실행 단계 :
        <pre>
            기본 조건 : var pattern = /a/;

            ▶ RegExp.exec(문자열)
                console.log(pattern.exec('abcdef'));   //출력 : ["a"], 이유 : 정규 표현식에서 표현한 a가 존재하기 때문에, 배열을 반환한다.
                console.log(pattern.exec('bcdef'));    //출력 : null, 이유 : 정규 표현식에서 표현한 a가 존재하지 않기 때문에
            ▶ RegExp.test(문자열)
                console.log(pattern.test('abcdef'));   //출력 : true, 이유 : 정규 표현식에서 표현한 a가 존재하기 때문에
                console.log(pattern.test('bcdef'));    //출력 : null, 이유 : 정규 표현식에서 표현한 a가 존재하지 않기 때문에
            </pre>
    </span>
    <span>정규 표현식 - 문자열 메소드 :
        <pre>
            기본 조건 : var pattern = /a/;

            ▶ String.match(객체명)
                RegExp.exec(문자열)와 비슷하다.

                console.log('abcdef'.match(pattern));   //출력 : ["a"], 이유 : 정규 표현식에서 표현한 a가 존재하기 때문에, 배열을 반환한다.
                console.log('bcdef'.match(pattern));    //출력 : null, 이유 : 정규 표현식에서 표현한 a가 존재하지 않기 때문에
            ▶ String.replace(객체명, 교체 문자열)
                console.log('abcdef'.replace(pattern, 'A'));   //출력 : Abcdef
                console.log('abcdefa'.replace(pattern, 'A'));   //출력 : Abcdefa, 맨 앞 글자만 바뀐다.
        </pre>
    </span>
    <span>정규 표현식 - 옵션 :
        <pre>
            기본 조건 : var pattern = /a/;

            ▶ i 옵션 : 대소문자를 구분 하지 않는다.
                var p = /a/;
                var pI = /a/i;

                console.log('Abcdef'.match(p));   //출력 : null, 이유 : 대소문자를 구분하기 때문에 A는 안되고 a만 가능하다.
                console.log('Abcdef'.match(pI));  //출력 : ["a"], 이유 : 대소문자를 구분하지 않기 때문에 i 옵션으로 인해 a도 A도 가능하다.
            ▶ g 옵션 (Global): 검색된 모든 결과를 리턴한다.
                var p = /a/;
                var pG = /a/g;
    
                console.log('abcdef'.match(p));   //출력 : ["a"], 이유 : 정규 표현식에 맞는 첫 번째 결과만 출력한다.
                console.log('abcdefa'.match(pG));  //출력 : ["a","a"], 이유 : 정규 표현식에 맞는 모든 결과를 출력한다.
            ▶ 옵션은 동시에 사용 가능하다
                var pIG = /a/ig;
    
                console.log('abcdefA'.match(pIG));   //출력 : ["a","A"]
        </pre>
    </span>
    <span>정규 표현식 - 캡쳐 :
        <pre>
            ▶ 괄호 안의 패턴은 마치 변수처럼 재사용 할 수 있다. ($ 기호 사용)
                var pattern = /(\w+)\s(\w)/;
                var str = "Hello World";
                var result = str.replace(pattern, "$2 ~ $1");
                console.log(result);    //출력 : World ~ Hello
                //이유 : $는 정규 표현식에서 그룹을 나타낸다. (배열처럼 0부터가 아니라 1부터 사용)
                그래서 $2와 $1을 위치를 바꾸는 표현식을 나타냈기 때문에 저렇게 바뀌는 것이다.
        </pre>
    </span>
    <span>정규 표현식 - 치환 :
        <pre>
            var urlPattern = /\b(?:https?):\/\/[a-z0-9-+&@#\/%?=~_|!:,.;]*/gim;
            var content = '네이버의 홈페이지 주소는 http://naver.com 입니다.';
            var result = content.replace(urlPattern, function(url){
                return '<a href="'+url+'">'+url+'</a>';
            });
            console.log(result);
            //출력 : "네이버의 홈페이지 주소는 <a href="http://naver.com">http://naver.com</a> 입니다."
            //이유 : replace의 첫번째 인자는 정규 표현식 객체명이다. 그리고 평소대로라면 두 번째 인자는 교체할 문자열이다.
            //       그런데 만약 replace의 두 번째 인자를 인자를 받는 함수로 선언하면,
            //       패턴에 맞는 문자열이 있을 때 해당 문자열이 자동으로 함수의 인자로 들어가도록 약속되어있기 떄문이다.
        </pre>
    </span>
    <span>정규 표현식 - 패턴 (역슬래시 + 문자):
        <pre>
            1. \w : A ~ Z, a ~ z, 0 ~9 모두 포함
            2. \s : 공백 (White Space)
        </pre>
    </span>
    <span>정규 표현식 - 패턴 (기호):
        <pre>
            1. () : 그룹화
            2. + : 앞의 것이 하나 이상인 경우, 패턴이 만약 \w+라면 문자열이 '#'이면 실패, 'abc'면 성공이다.
        </pre>
    </span>

    <hr>

    <span><bold>함수 지향 - 유효 범위 영역</bold></span>
    <span>변수의 유효 범위
        <pre>
            ▶ 전역 변수 : 에플리케이션 전역에서 접근이 가능한 변수
            ▶ 지역 변수 : 함수 내부에서 사용하는 제한적인 변수
        </pre>
    </span>
    <span>선언에 따른 변수의 유효 범위 변화
        <pre>
            var varScope = 'global';
            function scopeTest(){
                varScope = 'local';
                alert(varScope);//출력 : local, 이유 : varScope의 값이 local로 초기화 되었기 때문에
            }
            scopeTest();
            alert(varScope);//출력 : local, scopeTest 함수 안에서 varScope 앞에 var가 붙지 않았기 때문에 전역변수 취급받기 때문이다.

            즉, 변수를 초기화할 때에는 (특히, 함수 내부에서 초기화할 때) var같은 자료형을 붙이는 것을 습관화 해야 한다.
        </pre>
    </span>
    <span>유효 범위를 신경써야 되는 이유
        <pre>
            var resultA=0, resultB=0;
            function a (){
                i=0;       //전역 변수의 경우
            }
            function b (){
                var i = 0; //지역 변수의 경우
            }
            for(var i = 0; i < 5; i++){
                a();    //전역 변수의 경우
                resultA+=i;
            }
            for(var i = 0; i < 5; i++){
                b();    //지역 변수의 경우
                resultB+=i;
            }
            console.log("결과 A : " + resultA);     //출력 : 0, 애초에 무한 반복이라 사실 결과 안 나옴
            console.log("결과 B : " + resultB);     //출력 : 10

            기본 전제 : for문을 돌렸을 때 i가 var를 통해 선언된다. 즉, for문의 조건에 있는 i가 전역변수
            resultA가 0이 나오는 이유 :
                var를 붙이지 않고 변수를 선언하면 전역변수가 된다.
                for문의 조건식에서 돌아가는 i를 for문 내부의 a()에서 전역변수 상태로 계속 0으로 초기화시키기 때문에
                계속 무한 루프를 시킨다.
            resultB가 10이 나오는 이유 :
                for문 내부의 b()에서 초기화 되는 i는 var를 붙였기 때문에 b() 내부에서만 사용되는 아예 다른 i다.
                그렇기 때문에 for문이 정상적으로 작동해서 결과값이 10이 된 것이다.
        </pre>
    </span>
    <span>전역 변수 사용법
        하나의 객체를 전역 변수로 만들고 객체의 속성으로 변수를 관리한다.<br>
        <pre>
            studentInfo = {};
            studentInfo.score = {
                "korea" : null,
                "english" : null,
                "math" : null
            };
            studentInfo.personal = {
                "name" : null,
                "age" : null,
                "grade" : null,
                "class" : null,
                "no" : null
            }

            사용 => studentInfo.score.math = 90;
        </pre>
    </span>
    <span>유효 범위의 대상
        <pre>
            for(var i = 0; i < 5; i++){
                var name="test name";
            }
            alert(name);    //출력 : test name

            위의 코드를 진행한 후에

            testFunction=function(){var name="test name?";};
            testFunction();
            alert(name);    //출력 : test name, 이유 : var에 의한 전역변수/지역변수 구분은 함수의 내외에서만 구분된다. 그 외에는 항상 전역변수
        </pre>
    </span>
    <span>정적 유효 범위 : 자바스크립트의 함수가 선언된 시점에서의 유효 범위 ( = 정적 유효 범위, 렉시컬)
        <pre>
            var i = 5;
            function a(){
                var i = 10;
                b();
            }
            function b(){
                console.log(i);
            }
            a();
            
            이렇게 코드가 있을 때 결과는 어떻게 되는가?
            5가 출력 된다.
            왜냐하면 언뜻보면 a()가 실행되고 그 안에서 b()가 실행되어서 i가 10이 될 것 같지만
            b()는 자신의 내부의 코드에서 사용하는 i가 자신의 인자에 있는지 먼저 살펴본 다음에,
            존재하지 않을 경우에는 자신이 호출됬을 때가 아닌 자신이 정의 됬을 때의 i의 값인 5를 가져오게 된다.
            이렇게 자신이 호출됬을 때가 아닌 자신이 정의 됬을 때의 값을 가져오게 되는 것을 정적 유효 범위라고 한다.
        
            ▶ 실험 1 : a() 내부의 b()가 b(i)고, b()는 그대로 b()인 경우
            ▶ 결과 1 : 5 출력

            ▶ 실험 1 : a() 내부의 b()가 b(i)고, b()도 b(i)인 경우 => 보통의 프로그래밍
            ▶ 결과 1 : 10 출력
        </pre>
    </span>

    <hr>

    <span><bold>함수 지향 - 값으로서의 함수와 콜백 함수 영역</bold></span>
    <span>값으로서의 함수 : JavaScript에서는 함수도 객체이기 떄문에 일종의 값이 될 수 있음을 의미한다.
        <pre>
            function test(){}는 var test = function(){};와 같다.
        </pre>
    </span>
    <span>메소드 : 객체의 속성 값으로 담겨진 함수
        <pre>
            var testA = function(){};

            var testB = {
                subject : function(){
                    console.log('execute test.subject()');
                }
            };
        </pre>
    </span>
    <span>함수의 값으로서의 전달 방법
        <pre>
            //문자열을 만드는 함수
            function printTest(func, num){
                return num + '의 제곱은 ' + func(num) + '입니다.';
            }

            //제곱의 결과를 반환하는 함수
            function squaredTest(num){
                return num*num;
            }

            //함수를 실행하여서 결과 출력
            console.log(printTest(squaredTest,3));   //출력 : 3의 제곱은 9입니다.
            //이유 : printTest의 return에 보면 사용하는 인자 중 func의 뒤에 (num)이 붙어있다.
            //       이는 해당 인자를 함수로 사용하겠다는 JavaScript의 문법이다.
            //       그래서 이대로 실행하게 되면 func라는 인자에는 squaredTest(num)라는 함수가 들어가서
            //       num이라는 인자를 받아서 실행한 뒤에 차례대로 리턴하여서 마지막에는 결과값으로 문자열을 리턴해주게 된다.
        </pre>
    </span>
    <span>리턴 값으로서의 함수 사용
        <pre>
            function cal(mode){
                var funcs = {
                    'plus' : function(left, right){return left + right},
                    'minus' : function(left, right){return left - right}
                }
                return funcs[mode];
            }
            alert(cal('plus')(2,1));
            alert(cal('minus')(2,1));

            //실행 과정
            //0. 가정 : alert(cal('plus')(2,1));를 실행
            //1. 먼저, cal('plus') 실행된다.
            //2. cal 함수를 통해서 funcs['plus']라는 배열의 데이터가 리턴된다.
            //   이 때, func['plus']는 function(left, right){return left + right}라는 함수를 값으로 전달하게 된다.
            //3. 값으로 함수를 반환하는 것 이전에 함수는 변수의 속성이 될 수 있다고 하였다.
            //   즉, funcs['plus']= function(left, right){return left + right}가 된다.
            //   JavaScript의 기본적인 함수 모양으로 바꾸면 아래의 코드처럼 바뀐다.
            //   function funcs['plus'](left, right){
            //       return left + right;
            //    }
            //   그저 함수의 이름이 test나 example이 아니라 funcs['plus']가 됬을 뿐이다.
        </pre>
    </span>
    <span>배열로서의 함수 사용
        <pre>
            var process = [
                function(input){ return input + 10;},
                function(input){ return input * input;},
                function(input){ return input / 2;}
            ];
            var input = 1;
            for(var i = 0; i < process.length; i++){
                input = process[i](input);
            }
            alert(input);   //출력 : 60.5, 이유 : 1 → 11 → 121 → 60.5
        </pre>
    </span>
    <span>정렬하기, sort 메소드는 return 값이 음수/0/양수인지에 따라서 순서를 바꾼다.
        <pre>
            function sortNumberAmB(a,b){
                return a-b;
            }
            function sortNumberBmA(a,b){
                return b-a;
            }
            
            var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];

            alert(numbers.sort(sortNumberAmB));
            // array, [1,2,3,4,5,6,7,8,9,10,20] => 비교 함수 (a, b)의 결과 값이 음수면 a가 앞으로 간다.

            alert(numbers.sort(sortNumberBmA));
            // array, [20,10,9,8,7,6,5,4,3,2,1] => 비교 함수 (a, b)의 결과 값이 음수면 b가 앞으로 간다.
            
            //0인 경우에는 해당 요소를 제외한 다른 모든 데이터들에 대해서 정렬한다.
        </pre>
    </span>

    <hr>

    <span><bold>함수 지향 - 클로저</bold></span>
    <span>클로저 (closure) : 내부 함수가 외부 함수의 맥락 (context)에 접근할 수 있는 것
        <pre>
            function test(){}는 var test = function(){};와 같다.
        </pre>
    </span>
    <span>내부 함수 : 함수 안에서 또 다른 함수를 선언할 수 있는 JavaScript 문법
        <pre>
            function outside(){
                function inside(){
                    var text = "text";
                    console.log(text);
                }
                inside();
            }
            outside();

            //내부 함수는 외부 함수의 지역 변수에 접근할 수 있다.
            //위의 함수를 아래처럼 바꿔도 정상적으로 작동한다.
            //inside(text)로 선언된 것이 아니라 inside()로 인자가 없다고 선언되어있음에도
            //내부 함수이기 때문에 외부 함수의 지역 변수인 text를 사용할 수 있는 것이다.
            function outside(){
                var text = "text";
                function inside(){
                    console.log(text);
                }
                inside();
            }
            outside();
        
            //또 다른 방식으로도 사용 가능하다.
            function inside(){
                var text = "text";
                return function (){ console.log(text); }
            }
            var outside = inside();
            outside();
        </pre>
    </span>
    <span>private variable : 아무나 수정할 수 있는 것을 방지하는 것
        <pre>
            function factory_movie(title){
                return {
                    get_title : function (){
                        return title;
                    },
                    set_title : function(setTitle){
                        if(typeof setTitle === 'String'){
                            title = setTitle;
                        }
                        else{
                            alert('제목은 문자열이어야 합니다.');
                        }
                    }
                }//객체 리턴
            }

            ironman = factory_movie('iron'); //실행 1
             
            alert(ironman.get_title()); //실행 2
             
            ironman.set_title('iron man'); //실행 3
             
            alert(ironman.get_title()); //실행 4

            //해설 1 : ironman이라는 전역 변수에 factory_movie(title)을 실행해서 객체로 초기화
            //해설 2 : ironman.get_title()을 사용했더니 'ironman'이 아니라 'iron'이 출력된다. 이룰 수정하려고 한다.
            //해설 3 : ironman의 title을 set_title(setTitle)을 통해서 'ironman'로 변경했다.
            //해설 4 : 정상적으로 'ironman'으로 출력된다.

            //추가 해설 (set_title의 작동에 대한 이해)
            //1, factory_movie(title)에서 title은 factory_movie(title)의 매개 변수가 되는 것이다.
            //2. 이것은 factory_movie라는 함수 안에 title이라는 지역 변수가 있음을 의미한다.
            //3. 클로저(closure)는 내부 함수가 외부 함수의 지역 변수에 접근할 수 있는 것을 의미한다.
            //4. 즉, return으로 반환하는 객체의 내부 함수인 set_title은 factory_movie의 지역 변수인 title에 접근이 가능하다.
        </pre>
    </span>
    <span>클로저 사용시 주의점 : 내부 함수가 외부 함수의 지역 변수를 접근할 수 있다는 것이지<br>
          for문의 조건식의 i같은 변수에 바로 접근할 수 있다는 뜻이 아니다.<br>
          만약 for문의 i같은 변수에 바로 접근하고 싶다면 아래와 같이 코드를 작성하면 된다.
        <pre>
            var arr = []
            for(var i = 0; i < 5; i++){
                arr[i] = function(id) {
                    return function(){
                        return id;
                    }
                }(i);
            }
            for(var index in arr) {
                console.log(arr[index]());
            }

            //해설
            //1. 우선, for문이 실행되면 arr[i] = function(id) {...}(i);가 된다.
            //   즉, arr[i]안에 명시된 i를 익명 함수의 id라는 매개 변수로 주어서
            //   함수를 실행하는 것하며 그 결과를 저장한다.
            //2. 현재 익명 함수 안에는 또 다른 익명 함수가 있다.
            //   현재 외부 함수에는 i의 값을 받아 초기화 시킨 id라는 매개 변수가 있다.
            //3. 그렇기 때문에 내부 함수에서 외부 함수의 지역 변수인 id에 접근해서 그 값을 리턴해줄 수 있게 되는 것이다.
        </pre>
    </span>

    <hr>

    <span><bold>함수 지향 - arguments</bold></span>
    <span>arguments : 함수에서 사용된 인자들이 저장되는 유사 배열
        <pre>
            function sumTest(){
                var i, sum = 0;    
                for(i = 0; i < arguments.length; i++){
                    console.log(i+' : '+arguments[i]);
                    sum += arguments[i];
                }   
                return sum;
            }
            console.log('result : ' + sumTest(1,2,3,4));    //출력 : 10
        </pre>
    </span>
    <span>functionName.length & arguments.length
        <pre>
            함수명.length는 함수에서 선언되 있는 매개 변수의 개수를 의미한다.
            arguments.length는 함수를 실행할 때 실제로 들어온 매개 변수의 개수를 의미한다.

            function twoArg(arg1, arg2){
                console.log(
                    'twoArg.length', twoArg.length,
                    'arguments', arguments.length
                );
            }
            twoArg('val1');  //twoArg.length 2 arguments 1
            twoArg('val1', 'val2'); //출력 : twoArg.length 2 arguments 2
            twoArg(); //출력 : twoArg.length 2 arguments 0
        </pre>
    </span>

    <hr>

    <span><bold>함수 지향 - 함수의 호출</bold></span>
    <span>함수는 Function이라는 객체의 인스턴스이기 때문에 Function의 메소드인<br>
          Function.apply와 Function.call이라는 메소드들을 상속하고 있다.
        <pre>
            ▶ 기본적인 호출 방법
                function test(){
                    
                }
                test();
            ▶ Function.aplly => 메소드명.(현재 객체로 사용될 객체명, 전달될 인수들로 이루어진 배열)
                만약 function sum(a,b) { return a+b; }라는 함수가 있다면
                기본적으로는 sum(1,3);으로 호출하겠지만
                Function의 메소드인 apply를 사용해서
                sum.apply(null, [1,2]);로 호출할 수도 있다.
                하지만 null의 경우에는 굳이 apply 보다는 그냥 바로 sum(1, 2);로 호출하는 것이 낫다.

                var arr1 = {val1:1, val2:2, val3:3};
                var arr2 = {v1:10, v2:50, v3:100, v4:25};

                function sum(){
                    var result = 0;
                    for(name in this){
                        result += this[name];
                    }
                    return result;
                }

                alert(sum.apply(arr1)) //출력 : 6
                alert(sum.apply(arr2)) //출력 : 185

                //해설
                //1. apply에 arr1나 arr2라는 배열을 넣으면 해당 배열의 데이터들이 실행하는 함수의 인자가 된다.
                //2. apply의 인자로 넣은 배열은 해당 함수의 this라는 변수의 값이 된다.
            ▶ Function.call => 메소드명.(현재 객체로 사용될 객체명, 인수1, 인수2, ...)
                apply와 비슷하며, 인자를 넣는 방식만 좀 다르다.
                call의 경우에는 Java에서 객체를 초기화하는 것이라고 생각하면 편하다.

                function Product(name, price) {
                    this.name = name;
                    this.price = price;
                  }
                  
                function Food(name, price) {
                    Product.call(this, name, price);//this라는 객체에 Food의 인자로 받은 name과 price라는 변수를 전달
                    this.category = 'food';
                }

                var test=new Food('cheese', 5);
                console.log(test.name); //출력 : cheeze
        </pre>
    </span>
    <script src="studyJavaScript.js"></script>
</body>
</html>