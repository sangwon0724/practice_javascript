<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>리액트 JS 공부</title>
    <style>
        .animation_btn_flex{
            width: 50vw;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        #aniTarget{
            width: 100px;
            height: 100px;
            background-color: lightskyblue;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>
    <section id="start" tag="기초정보 기초 시작 디렉터리 디렉토리 jsx">
        <span><bold>기초정보</bold></span>
            <span>리액트의 시작</span>
            <pre>
                1. 기존의 리액트는 노드처럼 웹 브라우저가 읽지 못해서 웹팩이나 바벨을 통해 못생긴 코드로 변경해줘야 했다.
                2. 하지만 최근의 리액트는 npx create-react-app [만들 앱 이름]을 통해서 간편하게 실행할수 있게 되었다.
                    (※ npm의 5.2.0 버젼부터 새로 추가된 도구다.)
                3. 터미널에서 cd [만들었던 앱 이름]을 해서 해당 폴더로 이동한다.
                4. 그 이후에 npm start를 하게 되면 2개의 URL을 보여주는데 Local은 본인의 컴퓨터에서 이동할때의 URL이고,
                On Your Network는 Wi-fi가 연결되어 있을때 실행할 수 있는 URL이다.
            </pre>
            <span>디렉터리 정보</span>
            <pre>
                ● node_modules는 NodeJS의 실행 모듈들이 들어있는 폴더다.
                ● publice은 앱이 기본적으로 실행될 때 시작되는 index.html 맟 기타 파일들이 들어있는 폴더다.
                ● src는 css 및 js 파일들이 들어있는 폴더다.
            </pre>
            <span>핵심단어</span>
            <pre>
                ● jsx : javascript + html  
            </pre>
    </section>

    <br>

    <section id="component" tag="컴포넌트 정보보내기 보내기 클래스 클래스컴포넌트">
        <span><bold>컴포넌트</bold></span>
            <span>기초 정보</span>
            <pre>
                ● 리액트는 컴포넌트와 함께 동작한다.
                ● 리액트 앱은 하나의 컴포넌트만을 랜더링 해야한다. (App)
                ● 새로운 기능을 추가할 때에는 App.js에 추가한다.
                ● 컴포넌트는 &lt;App/>처럼 html코드처럼 사용되지만 엄연한 하나의 함수다.
                ● 리액트는 컴포넌트를 가져와서 브라우저가 이해할 수 있는 평범한 일반 html로 만든다.
                ● 리액트의 컴포넌트에 key 속성을 부여해서 각 속성값이 유일하도록 만든다.
                    이유 : 실제 값이 달라도 리액트가 스마트하지않게 작동해서 오류를 일으킨다.
                ● 리액트에서 class는 js의 클래스를 가리키기 떄문에 return에서 사용되는 html 태그내의 class 속성은
                  class가 아닌 className으로 명시해야 한다.
                ● 리액트에서 for는 js의 반복문을 가리키기 떄문에 return에서 사용되는 label 태그내의 for 속성은
                  for가 아닌 htmlFor으로 명시해야 한다.
            </pre>
            <span>컴포넌트 기본 사용법</span>
            <pre>
                1.
                    function WhatEver(){
                        return &lt;h1>Hello React&lt;/h1>;
                    }라고 작성하여 WhatEver라는 함수를 만든다. (예시)
                
                2. App 함수 안에서 &lt;WhatEver/>를 작성하여 함수를 실행한다.
            </pre>
            <span>컴포넌트에 정보 보내기</span>
            <pre>
                1. &lt;WhatEver/>라는 컴포넌트가 존재한다고 했을 때 원하는 이름의 속성을 추가한다.
                
                2. WhatEver 함수에 인자로 props (예시)라고 준다.

                3. 그럼 다음에 console.log로 props를 출력해보면 해당 컴포넌트가 가지고 있는 속성들에 대한 정보를 알 수 있다.
            </pre>
            <span>클래스 컴포넌트</span>
            <pre>
                ● 함수 컴포넌트는 뭔가를 return하고 screen에 표시된다.
                ● 클래스 컴포넌트는 클래스여야 하지만 리액트 컴포넌트로부터 확장되고 screen에 표시된다.

                ★ 리액트는 자동적으로 모든 클래스 컴포넌트에 있는 render 메소드를 자동으로 실행한다.

                ● 기본 선언 방법
                    class Ap extends React.Component{
                        render(){
                        return <h1>Hello</h1>;
                        }
                    }

                ● 클래스 컴포넌트에서 값 부여하기
                    class App extends React.Component {
                        state = {
                        count: 0
                        };
                        add = () => {
                        this.setState(current => ({ count: current.count + 1 }));
                        };
                        minus = () => {
                        this.setState(current => ({ count: current.count - 1 }));
                        };
                        render() {
                        return (
                            &lt;div>
                                &lt;h1>The number is: {this.state.count}&lt;/h1>
                                &lt;button onClick={this.add}>Add&lt;/button>
                                &lt;button onClick={this.minus}>Minus&lt;/button>
                            &lt;/div>
                        );
                        }
                    }

                    ※ state 속성과 setState 함수를 사용해서 속성의 값을 수정한다.
                    ※ setState 함수를 쓰게되면 함수가 실행될때마다 자동으로 랜더링되서 값이 변경된다.
                    ※ setState 함수를 사용할 때 state 안에 없는 속성을 명시해도 오류는 생기지 않는다.

                ● 클래스 컴포넌트의 빌드 순서 (첫 빌드시)
                    (1) constructor (내부에 super()가 반드시 필요)
                    (2) render
                    (3) componentDidMount

                ● 클래스 컴포넌트의 빌드 순서 (업데이트시 = setState 함수 실행시)
                    (1) render
                    (2) componentDidUpdate

                ★ return 할 때 ()로 묶는다.
            </pre>
    </section>

    <br>

    <section id="grammer" tag="문법">
        <span><bold>리액트 문법</bold></span>
            <span>App()의 return 안에서 javascript 쓰기</span>
            <pre>
                ※ 그냥 쓰면 html이고, {}를 통해서 사용하면 javascript다.

                function Whatever({prop}){
                    return &lt;h1>● {prop}&lt;/h1>&lt;br>;
                }

                function ArrayTest(element){
                    return &lt;Whatever prop={element.prop} />;
                }

                function App(){
                    return {
                        &lt;div>
                            {whatevetArray.map(ArrayTest)}
                        &lt;/div>
                    };
                }
            </pre>
    </section>

    <br>

    <section id="propTypes" tag="프로토타입 프로프타입 기본 prototype propType propTypes">
        <span><bold>프로프타입</bold></span>
        <span>필요 이유</span>
        <pre>
            ● 프로그래머도 사람이기 때문에 실수가 생길수 있으니 속성명을 잘못 명시하는 등의 실수를 방지하기 위해서 사용한다.
        </pre>
        <span>설치방법</span>
        <pre>
            ● npm i prop-types을 통해서 설치한다.
        </pre>
        <span>사용방법</span>
        <pre>
            ● App.js에 import PropTypes from "prop-types";를 통해서 import한다.
            ● WhatEverProtoType.propTypes = {
                name: PropTypes.string.isRequired,
                picture: PropTypes.string.isRequired,
                rating: PropTypes.number
              };처럼 선언한다.
            ● isRequired는 값이 반드시 필요함을 의미한다.
            ● isRequired를 사용하지 않으면 값이 없거나 타입이 맞지 않아도 에러가 발생하지 않는다.
        </pre>
    </section>

    <br>

    <section id="axios" tag="axios fetch 패치 악시오스 읽기">
        <span><bold>axios</bold></span>
        <span>필요 이유</span>
        <pre>
            ● 데이터를 읽기 위해 사용하는 fetch 대신에 사용하는 API
        </pre>
        <span>설치방법</span>
        <pre>
            ● npm install axios를 통해서 설치한다.
        </pre>
        <span>사용방법</span>
        <pre>
            ● App.js에 import axios from "axios";를 통해서 import한다.
            ● getMovies = async () => {
                const movies
                    = await axios.get("https://yts-proxy.now.sh/list_movies.json?sort_by=rating");
            }처럼 사용한다.
        </pre>
    </section>

    <br>

    <section id="gh_pages" tag="github io 깃허브 아이오 깃허브페이지 페이지">
        <span><bold>깃허브 페이지</bold></span>
        <span>사용방법</span>
        <pre>
            ● npm run build를 실행한다.
            ● 해당 프로젝트에 gh-pages 브랜치를 추가한다.
            ● gh-pages 브랜치로 이동한다.
            ● build 폴더의 내용물들을 전부 루트 경로로 꺼낸다.
            ● 커밋한 다음에 https://[유저명].github.io/[프로젝트명]/으로 이동한 후 좀 기다리다가 제대로 파일이 올라갔나 확인한다.
        </pre>
    </section>

    <br>

    <section id="navigation" tag="navigation 네비게이션 router dom 돔 네비">
        <span><bold>네비게이션</bold></span>
        <span>설치방법</span>
        <pre>
            ● npm install react-router-dom을 실행한다.
        </pre>
        <span>컨트롤러 만들기</span>
        <pre>
            1. App.js에 import {HashRouter, Route} from "react-router-dom";를 통해서 import한다.
            2. return에서 &lt;HashRouter>&lt;Route/>&lt;/HashRouter>를 명시한다.
            3. Route를 사용할 js 파일을 import 한다. (예시 : import About from "./route/About";)
            4. Route의 path 속성에 이동할 경로명을 명시한다. (예시 : &lt;Route path="/about"/>)
            5. Route의 component 속성에 이동할 js 파일의 이름을 명시한다. (예시 : &lt;Route path="/about" component={About}/>)
            6. 두 개 이상의 경로를 지정할 때는 그냥 HashRouter 태그 안에 계속 추가하면 된다.
            7. 스프링과 달리 리액트에서는 중간에 거치는 url들에 해당하는 Route들도 랜더링하기 때문에 이를 피하기 위해 exact={true}를 사용하여
               현재 접속중인 url과 Route 태그에 명시된 path가 동일한 것만 랜더링 하도록 한다. 
        </pre>
        <span>네비게이션 메뉴 만들기</span>
        <pre>
            1. navigation.js에 import { Link } from "react-router-dom";를 통해서 import한다.
            2. a 태그는 아예 이동을 시켜버리기 때문에 상호작용되는 페이지를 만들기 위해 Link 태그를 사용한다.
            3. Link 태그 예시 => &lt;Link to="/about">About&lt;/Link> 
        </pre>
    </section>

    <div id="remote">
        <section id="remote_setcion">
            <select id="remote_menu">
                <option value="start">기초정보</option>
                <option value="component">컴포넌트</option>
                <option value="grammer">리액트 문법</option>
                <option value="propTypes">프로토타입</option>
                <option value="axios">axios</option>
                <option value="gh_pages">깃허브 페이지</option>
                <option value="navigation">네비게이션</option>
            </select>
        </section>
    </div>

    <script src="./remote.js"></script>
</body>
</html>