<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>리액트 JS 공부</title>
    <style>
        .animation_btn_flex{
            width: 50vw;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        #aniTarget{
            width: 100px;
            height: 100px;
            background-color: lightskyblue;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>
    <section id="start" tag="기초정보 기초 시작 디렉터리 디렉토리 jsx">
        <header class="note_title">기초정보</header>
        <ul>
            <li>리액트의 시작
                <pre>
                    1. 기존의 리액트는 노드처럼 웹 브라우저가 읽지 못해서 웹팩이나 바벨을 통해 못생긴 코드로 변경해줘야 했다.
                    2. 하지만 최근의 리액트는 npx create-react-app [만들 앱 이름]을 통해서 간편하게 실행할수 있게 되었다.
                        (※ npm의 5.2.0 버젼부터 새로 추가된 도구다.)
                    3. 터미널에서 cd [만들었던 앱 이름]을 해서 해당 폴더로 이동한다.
                    4. 그 이후에 npm start를 하게 되면 2개의 URL을 보여주는데 Local은 본인의 컴퓨터에서 이동할때의 URL이고,
                    On Your Network는 Wi-fi가 연결되어 있을때 실행할 수 있는 URL이다.
                </pre>
            </li>
            <li>디렉터리 정보
                <pre>
                    ● node_modules는 NodeJS의 실행 모듈들이 들어있는 폴더다.
                    ● publice은 앱이 기본적으로 실행될 때 시작되는 index.html 맟 기타 파일들이 들어있는 폴더다.
                    ● src는 css 및 js 파일들이 들어있는 폴더다.
                </pre>
            </li>
            <li>핵심단어
                <pre>
                    ● jsx : javascript + html  
                </pre>
            </li>
        </ul>
    </section>

    

    <section id="component" tag="컴포넌트 정보보내기 보내기 클래스 클래스컴포넌트">
        <header class="note_title">컴포넌트</header>
        <ul>
            <li>기초 정보
                <pre>
                    ● 리액트는 컴포넌트와 함께 동작한다.
                    ● 리액트 앱은 하나의 컴포넌트만을 랜더링 해야한다. (App)
                    ● 새로운 기능을 추가할 때에는 App.js에 추가한다.
                    ● 컴포넌트는 &lt;App/>처럼 html코드처럼 사용되지만 엄연한 하나의 함수다.
                    ● 리액트는 컴포넌트를 가져와서 브라우저가 이해할 수 있는 평범한 일반 html로 만든다.
                    ● 리액트의 컴포넌트에 key 속성을 부여해서 각 속성값이 유일하도록 만든다.
                        이유 : 실제 값이 달라도 리액트가 스마트하지않게 작동해서 오류를 일으킨다.
                    ● 리액트에서 class는 js의 클래스를 가리키기 떄문에 return에서 사용되는 html 태그내의 class 속성은
                      class가 아닌 className으로 명시해야 한다.
                    ● 리액트에서 for는 js의 반복문을 가리키기 떄문에 return에서 사용되는 label 태그내의 for 속성은
                      for가 아닌 htmlFor으로 명시해야 한다.
                </pre>
            </li>
            <li>컴포넌트 기본 사용법
                <pre>
                    1.
                        function WhatEver(){
                            return &lt;h1>Hello React&lt;/h1>;
                        }라고 작성하여 WhatEver라는 함수를 만든다. (예시)
                    
                    2. App 함수 안에서 &lt;WhatEver/>를 작성하여 함수를 실행한다.
                </pre>
            </li>
            <li>컴포넌트에 정보 보내기
                <pre>
                    1. &lt;WhatEver/>라는 컴포넌트가 존재한다고 했을 때 원하는 이름의 속성을 추가한다.
                    
                    2. WhatEver 함수에 인자로 props (예시)라고 준다.
    
                    3. 그럼 다음에 console.log로 props를 출력해보면 해당 컴포넌트가 가지고 있는 속성들에 대한 정보를 알 수 있다.
                </pre>
            </li>
            <li>클래스 컴포넌트
                <pre>
                    ● 함수 컴포넌트는 뭔가를 return하고 screen에 표시된다.
                    ● 클래스 컴포넌트는 클래스여야 하지만 리액트 컴포넌트로부터 확장되고 screen에 표시된다.
    
                    ★ 리액트는 자동적으로 모든 클래스 컴포넌트에 있는 render 메소드를 자동으로 실행한다.
    
                    ● 기본 선언 방법
                        class Ap extends React.Component{
                            render(){
                            return &lt;h1>Hello&lt;/h1>;
                            }
                        }
    
                    ● 클래스 컴포넌트에서 값 부여하기
                        class App extends React.Component {
                            state = {
                            count: 0
                            };
                            add = () => {
                            this.setState(current => ({ count: current.count + 1 }));
                            };
                            minus = () => {
                            this.setState(current => ({ count: current.count - 1 }));
                            };
                            render() {
                            return (
                                &lt;div>
                                    &lt;h1>The number is: {this.state.count}&lt;/h1>
                                    &lt;button onClick={this.add}>Add&lt;/button>
                                    &lt;button onClick={this.minus}>Minus&lt;/button>
                                &lt;/div>
                            );
                            }
                        }
    
                        ※ state 속성과 setState 함수를 사용해서 속성의 값을 수정한다.
                        ※ setState 함수를 쓰게되면 함수가 실행될때마다 자동으로 랜더링되서 값이 변경된다.
                        ※ setState 함수를 사용할 때 state 안에 없는 속성을 명시해도 오류는 생기지 않는다.
    
                    ● 클래스 컴포넌트의 빌드 순서 (첫 빌드시)
                        (1) constructor (내부에 super()가 반드시 필요)
                        (2) render
                        (3) componentDidMount
    
                    ● 클래스 컴포넌트의 빌드 순서 (업데이트시 = setState 함수 실행시)
                        (1) render
                        (2) componentDidUpdate
    
                    ★ return 할 때 ()로 묶는다.
                </pre>
            </li>
        </ul>
    </section>

    <section id="grammer" tag="문법">
        <header class="note_title">리액트 문법</header>
        <ul>
            <li>App()의 return 안에서 javascript 쓰기
                <pre>
                    ※ 그냥 쓰면 html이고, {}를 통해서 사용하면 javascript다.
    
                    function Whatever({prop}){
                        return &lt;h1>● {prop}&lt;/h1>&lt;br>;
                    }
    
                    function ArrayTest(element){
                        return &lt;Whatever prop={element.prop} />;
                    }
    
                    function App(){
                        return {
                            &lt;div>
                                {whatevetArray.map(ArrayTest)}
                            &lt;/div>
                        };
                    }
                </pre>
            </li>
            <li>Fragment
                <pre>
                    ● React v16에 추가된 기능
                    ● 컴포넌트가 여러 엘리먼트를 return 할때 jsx 규칙상 하나의 태그로 묶어서 return 해줘야 하는데,
                      이때 fragment를 사용하면 dom에 별도의 노드를 추가하지 않고 여러자식을 그룹화 할 수 있다.
                    ● 기본 문법 : &lt;React.Fragment>&lt;컴포넌트명>&lt;/React.Fragment>
                    ● 간략화 문법 : &lt;>&lt;컴포넌트명>&lt;/>
                </pre>
            </li>
        </ul>
    </section>

    

    <section id="propTypes" tag="프로토타입 프로프타입 기본 prototype propType propTypes">
        <header class="note_title">프로프타입</header>
        <ul>
            <li>필요 이유
                <pre>
                    ● 프로그래머도 사람이기 때문에 실수가 생길수 있으니 속성명을 잘못 명시하는 등의 실수를 방지하기 위해서 사용한다.
                </pre>
            </li>
            <li>설치방법
                <pre>
                    ● npm i prop-types을 통해서 설치한다.
                </pre>
            </li>
            <li>사용방법
                <pre>
                    ● App.js에 import PropTypes from "prop-types";를 통해서 import한다.
                    ● WhatEverProtoType.propTypes = {
                        name: PropTypes.string.isRequired,
                        picture: PropTypes.string.isRequired,
                        rating: PropTypes.number
                      };처럼 선언한다.
                    ● isRequired는 값이 반드시 필요함을 의미한다.
                    ● isRequired를 사용하지 않으면 값이 없거나 타입이 맞지 않아도 에러가 발생하지 않는다.
                    ● PropTypes.oneOf([x,y,...])는 배열 안에 있는 값들만 가능하다는 것을 의미한다.
                </pre>
            </li>
        </ul>
    </section>

    

    <section id="axios" tag="axios fetch 패치 악시오스 읽기">
        <header class="note_title">axios</header>
        <ul>
            <li>필요 이유
                <pre>
                    ● 데이터를 읽기 위해 사용하는 fetch 대신에 사용하는 API
                </pre>
            </li>
            <li>설치방법
                <pre>
                    ● npm install axios를 통해서 설치한다.
                </pre>
            </li>
            <li>사용방법
                <pre>
                    ● App.js에 import axios from "axios";를 통해서 import한다.
                    ● getMovies = async () => {
                        const movies
                            = await axios.get("https://yts-proxy.now.sh/list_movies.json?sort_by=rating");
                    }처럼 사용한다.
                </pre>
            </li>
        </ul>
    </section>

    

    <section id="gh_pages" tag="github io 깃허브 아이오 깃허브페이지 페이지">
        <header class="note_title">깃허브 페이지</header>
        <ul>
            <li>사용방법
                <pre>
                    ● npm run build를 실행한다.
                    ● 해당 프로젝트에 gh-pages 브랜치를 추가한다.
                    ● gh-pages 브랜치로 이동한다.
                    ● build 폴더의 내용물들을 전부 루트 경로로 꺼낸다.
                    ● 커밋한 다음에 https://[유저명].github.io/[프로젝트명]/으로 이동한 후 좀 기다리다가 제대로 파일이 올라갔나 확인한다.
                </pre>
            </li>
        </ul>
    </section>

    

    <section id="navigation" tag="navigation 네비게이션 router dom 돔 네비 컨트롤러">
        <header class="note_title">네비게이션 (= 컨트롤러)</header>
        <ul>
            <li>설치방법
                <pre>
                    ● npm install react-router-dom을 실행한다.
                </pre>
            </li>
            <li>컨트롤러 만들기
                <pre>
                    1. App.js에 import {HashRouter, Route} from "react-router-dom";를 통해서 import한다.
                    2. return에서 &lt;HashRouter>&lt;Route/>&lt;/HashRouter>를 명시한다.
                    3. Route를 사용할 js 파일을 import 한다. (예시 : import About from "./route/About";)
                    4. Route의 path 속성에 이동할 경로명을 명시한다. (예시 : &lt;Route path="/about"/>)
                    5. Route의 component 속성에 이동할 js 파일의 이름을 명시한다. (예시 : &lt;Route path="/about" component={About}/>)
                    6. 두 개 이상의 경로를 지정할 때는 그냥 HashRouter 태그 안에 계속 추가하면 된다.
                    7. 스프링과 달리 리액트에서는 중간에 거치는 url들에 해당하는 Route들도 랜더링하기 때문에 이를 피하기 위해 exact={true}를 사용하여
                       현재 접속중인 url과 Route 태그에 명시된 path가 동일한 것만 랜더링 하도록 한다. 
                </pre>
            </li>
            <li>네비게이션 메뉴 만들기
                <pre>
                    1. navigation.js에 import { Link } from "react-router-dom";를 통해서 import한다.
                    2. a 태그는 아예 이동을 시켜버리기 때문에 상호작용되는 페이지를 만들기 위해 Link 태그를 사용한다.
                    3. Link 태그 예시 => &lt;Link to="/about">About&lt;/Link> 
                </pre>
            </li>
            <li>상황에 따른 컨트롤러 만들기
                <pre>
                    1. import { HashRouter as Router, Route, Switch } from "react-router-dom";
                    2. 상황을 설정할 값 선언
                    3. 아래와 같은 틀의 코드 작성하기
                        &lt;Router>
                            &lt;Switch>
                            {isLoggedIn ? (
                                &lt;>
                                &lt;<Route exact path="/">
                                    &lt;Home />
                                &lt;/Route>
                                &lt;/>
                            ) : (
                                &lt;Route exact path="/">
                                    &lt;Auth />
                                &lt;/Route>
                            )}
                            &lt;/Switch>
                        &lt;/Router>
                </pre>
            </li>
            <li>리다이렉트 시키기
                <pre>
                    1. import { useHistory } from "react-router-dom";
                    2. history.push(URL);
                </pre>
            </li>
        </ul>
    </section>

    

    <section id="env" tag="">
        <header class="note_title">환경변수</header>
        <ul>
            <li>.env 파일 사용방법
                <pre>
                    ● 리액트에서 create-react-app을 사용한 이후에 .env 파일을 사용하고 싶다면
                      .env 파일 안에서 사용되는 환경변수명들 앞에는 반드시 "REACT_APP_"을 붙여야 한다.
                        예시) REACT_APP_PROJECT_ID=abc
                    ● 쉼표나 세미콜론이 아닌 엔터로 구분한다.
                    ● 사용할때는 process.env.REACT_APP_XXX=123로 사용할 수 있다.
                    ● 개인 API KEY를 가리기 위해 사용하는 경우가 많지만 결국 브라우저를 통해 요청되면 데이터가 이동하기 때문에 반드시 숨겨지는것은 아니다.
                </pre>
            </li>
        </ul>
    </section>

    

    <section id="path" tag="">
        <header class="note_title">경로설정</header>
        <ul>
            <li>jsconfig.json 사용방법
                <pre>
                    1. jsconfig.json 파일을 package.json 파일과 같은 위치에 만들어서 아래의 코드를 복붙한다.
                        {
                            "compilerOptions": {
                                "baseUrl": "src"
                            },
                            "include": [
                                "src"
                            ]
                        }
                    2. import할 때 from의 주소를 절대경로로 작성한다.
                        ※ 기존 : import AppRouter from "./Router";
                        ※ 변경 : import AppRouter from "components/Router";

                    ※ 만약 작동하지 않는다면 vscode를 껐다가 다시 킨다.
                </pre>
            </li>
        </ul>
    </section>

    

    <section id="fontAwesome" tag="">
        <header class="note_title">fontAwesome 사용하기</header>
        <ul>
            <li>설치방법
                <pre>
                    1. 터미널에 명령어 npm install @fortawesome/react-fontawesome 입력하기
                    2. 필요한 아이콘에 따라서 추가로 터미널에 명령어 입력하기
                        ○ npm install @fortawesome/fontawesome-free
                        ○ npm install @fortawesome/fontawesome-svg-core
                        ○ npm install @fortawesome/free-brands-svg-icons
                        ○ npm install @fortawesome/free-regular-svg-icons
                        ○ npm install @fortawesome/free-solid-svg-icons
                </pre>
            </li>
            <li>사용방법
                <pre>
                    1. "@fortawesome/react-fontawesome" 패키지에서 FontAwesomeIcon를 import 받는다.
                            코드)
                                import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
                    1. 필요한 패키지에서 필요한 기능을 import 받는다.
                        예시)
                            (1) import { faTwitter } from "@fortawesome/free-brands-svg-icons";
                            (2) import { faUser } from "@fortawesome/free-solid-svg-icons";
                    2. &lt;FontAwesomeIcon/> 태그를 통해서 아이콘을 사용한다.
                        예시)
                            (1) &lt;FontAwesomeIcon icon={faTwitter} color={"#04AAFF"} size="2x" />
                            (2) &lt;FontAwesomeIcon icon={faUser} color={"#04AAFF"} size="2x" />
                </pre>
            </li>
        </ul>
    </section>

    <div id="remote">
        <article id="remote_setcion">
            <select id="remote_menu">
                <option value="start">기초정보</option>
                <option value="component">컴포넌트</option>
                <option value="grammer">리액트 문법</option>
                <option value="propTypes">프로토타입</option>
                <option value="axios">axios</option>
                <option value="gh_pages">깃허브 페이지</option>
                <option value="navigation">네비게이션 (= 컨트롤러)</option>
                <option value="env">환경변수</option>
                <option value="path">경로설정</option>
                <option value="fontAwesome">fontAwesome 사용하기</option>
            </select>
        </article>
    </div>

    <script src="./remote.js"></script>
</body>
</html>