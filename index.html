<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        b {font-size: 25px; font-weight: bold;}
        span {display: block; margin: 20px 0;}
    </style>
</head>
<body>
    <span><b>기본 영역</b></span>
    <span>알림 출력 : alert('알림');</span>
    <span>콘솔 출력 : console.log('콘솔');</span>
    <span>값 입력받기 : prompt('아무 값이나 입력해주세요!');</span>
    <span>Html 파일에 글 추가 : documnet.write("아무 문자");</span>
    <span>형변환 (숫자 → 문자) : String(3); //맨앞이 대문자</span>

    <hr>

    <span><b>숫자 및 문자열 영역</b></span>
    <span>수의 연산 :<br>
        Math.pow(3,2);       //출력 : 9,   3의 2승<br>
        Math.round(10.6);    //출력 : 11,  10.6을 반올림<br>
        Math.ceil(10.2);     //출력 : 11,  10.2를 올림<br>
        Math.floor(10.6);    //출력 : 10,  10.6을 내림<br>
        Math.sqrt(9);        //출력 : 3,   3의 제곱근<br>
        Math.random();       //출력 : 0부터 1.0 사이의 랜덤한 숫자 (소수점 포함)<br>
        Math.round(100*Math.random()+1);       //출력 : 1부터 100 사이의 랜덤한 숫자 (정수)
    </span>
    <span>자료형 확인 : alert(typeof [변수명 또는 숫자 또는 문자열]); //출력 예시 : string 또는 number</span>
    <span>문자열 더하기 : alert("Hello"+" World"); //출력 : Hello World</span>
    <span>문자열 길이 : "Hello World".length//출력 : 11</span>
    <span>문자 위치 구하기 : "code".indexof("c"); //출력 : 0</span>

    <hr>

    <span><b>변수 영역</b></span>
    <span>변수 선언 : <br>
        var f="te"; var b="st"; 또는 var f="te", b="st";<br>
        사용 => alert(f+b); //출력 : test
    </span>
    <span>변수 입력 받기 : <br>
        var name=prompt('당신의 이름은 무엇인가요?');//test 입력
        alert(name);    //출력 : test
    </span>

    <hr>

    <span><b>연산자 영역</b></span>
    <span>== 연산자 사용 (값만 같으면 됨) : <br>
        alert(1 == 2)             //출력 : false<br>
        alert(1 == 1)             //출력 : true<br><br>
        alert("one" == "two")     //출력 : false<br>
        alert("one" == "one")     //출력 : true
    </span>
    <span>=== 연산자 사용 (조건을 엄격하게 하여 비교 => 값과 자료형이 모두 같아야 됨) : <br>
        alert(1 == '1');          //출력 : true<br>
        alert(1 === '1');         //출력 : false<br><br>
        alert(null == undefined); //출력 : true<br>
        alert(null === undefined);//출력 : false<br><br>
        alert(true == 1);         //출력 : true<br>
        alert(true === 1);        //출력 : false<br>
        alert(true == '1');       //출력 : true<br>
        alert(true === '1');      //출력 : false<br><br>
        alert(0 === -0);          //출력 : true<br>
        alert(NaN === NaN);       //출력 : false<br>
    </span>
    <span>같지 않음을 비교하는 ==와 ===처럼 같지 않음을 비교하는 !=와 !==가 존재한다.<br>
        alert(1 != '1');          //출력 : false<br>
        alert(1 !== '1');         //출력 : true
    </span>
    <span>And를 의미하는 &&와 Or을 의미하는 ||가 있다.</span>

    <hr>

    <span><b>조건문 영역</b></span>
    <span>
        <pre>
        if(true){
            alert('result : true');
        }

        if(false){
            alert('result : true');
        }

        if(조건1){
            alert('if 결과');
        }
        else if(조건2){
            alert('else if 결과');
        }
        else {
            alert('else 결과');
        }

        switch ( condition ) {
            case value1:
              statement1;
              break;
            case value2:
              statement2;
              break;
            ...
            default:
              statement3;
          }

          //예시
          var test="test";
          switch ( test ) {
            case "test":
              console.log("test입니다.");
              break;
            case "notTest":
              console.log("notTest입니다.");
              break;
            case "whyTest":
              console.log("whyTest입니다.");
              break;
            default:
              console.log("default입니다.");
              break;
          }
          //출력 : test입니다.
        </pre>
    </span>
    <span>true나 false 대신에 1과 0을 쓸 수는 있지만 ==와 ===같은 것을 보면 실전에서는 그냥 true나 false를 쓰는 것이 낫다.</span>
    <span>조건에 변수명을 넣으면 만약 해당 변수가 비어있지 않다면 true를 비어있다면 false를 반환한다.</span>

    <hr>

    <span><b>반복문 영역</b></span>
    <span>
        <pre>
            for(초기화; 반복조건; 반복이 될 때마다 실행되는 코드){
                반복할 문장;
            }
            
            //예시
            for(var i = 0; i < 10; i++){
                document.write(i+' ');
            }

            while(조건)}{
                반복할 문장;
            }

            //예시
            var i = 0;
            while(i < 10){
                document.write(i+' ');
                i++;
            }

            //무한 반복
            while(ture){
                반복할 문장;
            }

            //반복 제어 - 반복 중지
            for(var i = 0; i < 10; i++){
                if(i===5){break;}//반복을 중지시키고 for문을 빠져나온다.

                document.write(i+' ');
            }

            //반복 제어 - 넘기기
            for(var i = 0; i < 10; i++){
                if(i===5){continue;}//i가 5일 때 반복을 한번 생략하고 다음 반복 (i가 6인 경우)을 진행한다.

                document.write(i+' ');
            }
        </pre>
    </span>

    <hr>

    <span><b>함수 영역</b></span>
    <span>함수 : 하나의 로직을 재실행할 수 있도록 하는 것</span>
    <span>함수의 특징 : <br>
        1. 코드의 재사용성을 높여준다.
        2. 유지보수가 용이하다.
        3. 가독성이 올라간다.
    </span>
    <span>
        <pre>
            < 선언 방법 1 >
            function 함수명(인자1, 인자2, ...){
                코드 내용;
                return 반환값;  //필요시 선언
            }

            < 선언 방법 2 >
            var 함수명 = function()(인자1, 인자2, ...){{
                코드 내용;
                return 반환값;  //필요시 선언
            }}

            < 함수 실행 방법 >
            함수명(인자 존재시 인자 개수만큼 선언);

            < 선언 방법 3 > - 함수 선언과 동시에 실행하는 방법 ( = 익명 함수 ), function의 앞뒤로 ()를 써 준다.
            (function()(인자1, 인자2, ...){{
                코드 내용;
                return 반환값;  //필요시 선언
            }})();
        </pre>
    </span>

    <hr>

    <span><b>배열 영역</b></span>
    <span>배열 (Array) : 연관된 데이터를 모아서 한꺼번에 관리하기 위해서 사용하는 데이터 타입</span>
    <span>선언 방법 : var test = ['test0', 'test1', 'test2']; //대괄호를 사용한다.<br>
          이 때 test를 출력하면 모든 요소를 콤마(,)로 구분하여 보여준다.<br>
          alert(test); //출력 : test0,test1,test2
    </span>
    <span>사용 방법 : 위의 test에서 'test0' 출력 => alert(test[0]);</span>
    <span>배열의 길이 : 변수명.length</span>
    <span>데이터 추가 방법 1 :<br>
        <pre>
          위의 test의 데이터의 개수가 3개이기 때문에 test[3]="test3";를 하게 되면<br>
          test는  ['test0', 'test1', 'test2', 'test3']가 된다.
          대신 이 경우에는 배열이 갖고 있는 데이터의 개수를 알고 있어야 한다.
        </pre>
    </span>
    <span>데이터 추가 방법 2 (배열의 맨 뒤에 요소를 추가): <br>
        <pre>
          위의 test라는 배열의 맨 뒤에 데이터를 추가하고 싶을 때에는 test.push("test3");를 하면 된다.<br>
          하지만 이 경우에는 배열이 갖고 있는 데이터의 개수를 알고 있지 않아도 된다.
        </pre>
    </span>
    <span>데이터 추가 방법 3 (배열의 맨 앞에 요소를 추가): <br>
        <pre>
          위의 test라는 배열의 맨 앞에 데이터를 추가하고 싶을 때에는 test.unshift("test-1");를 하면 된다.<br>
          하지만 이 경우에는 배열이 갖고 있는 데이터의 개수를 알고 있지 않아도 된다.
        </pre>
    </span>
    <span>데이터 추가 방법 4 (배열의 중간에 요소를 추가): <br>
          <pre>
          위의 test라는 배열의 중간에 데이터를 추가하고 싶을 때에는 test.splice(index, count, element...);를 하면 된다.<br>
          만약 test에서 2번째에 요소를 3개 추가하고 싶다면 test.splice(2, 0, 'test-s-1', 'test-s-2', 'test-s-3');가 된다.<br>
          실행하면 test는 ["test0", "test1", "test-s-1", "test-s-2", "test-s-3", "test2"]가 된다.<br>
          
          이 때 splice의 인자에서 index는 요소가 추가되기 시작할 번호를 의미한다.<br>
          여기서 index는 말 그대로 index기 때문에 2번째라는게 1,2번째의 2번째가 아니라 배열의 0,1,2의 2번째다.<br>
          count는 index로부터 삭제될 요소의 개수를 의미한다. 만약 0을 선언하면 아무 것도 삭제하지 않고 추가한다.<br>
          
          만약 test.splice(2, 1, 'test-s-1', 'test-s-2', 'test-s-3');를 하면 test는 ["test0", "test1", "test-s-1", "test-s-2", "test-s-3"]가 된다.<br>
          이 때 test.splice의 count 인자를 통해 삭제된 인자는 실제로 사용 가능한 값이다.<br>
          그래서 만약 alert(test.splice(2, 1, 'test-s-1', 'test-s-2', 'test-s-3'));를 하면 삭제되는 값들이 출력된다.<br>
          삭제되는 요소가 2개 이상이면 콤마(,)를 통해 연결되서 출력된다.
        </pre>
    </span>
    <span>데이터 추가 방법 5 (배열 합치기): <br>
        <pre>
          위의 test라는 배열말고 추가로 example이라는 배열이 있다고 가정해보자.<br>
          만약 example이 ['example0','example1','example2']라고 했을 때<br>
          test에 example의 요소를 합치고 싶을때는 어떻할까?<br>

          바로 concat이라는 함수를 이용하면 된다.<br>

          test=test.concat(example); 또는 test=test.concat(['example0','example1','example2']);처럼 사용한다.<br>
          그러면 test에 test의 뒤에 example의 요소들을 붙인 배열이 되어 저장된다. (결과 : ["test0", "test1", "test2", "example0", "example1", "example2"])<br>
        </pre>  
    </span>
    <span>데이터 삭제 방법 1 (배열의 맨 뒤의 요소를 삭제) :<br>
        <pre>
          위의 test라는 배열에서 데이터를 삭제하고 싶을 때에는 test.pop();를 하면 된다.<br>
          그러면 배열에서 가장 마지막에 추가된 요소부터 차례대로 삭제된다.<br>

          또한 다른 특징으로 변수명.pop()을 해서 요소를 삭제하면 단순하게 삭제만 되는 것이 아니라 실제로 삭제된 값을 사용할 수 있다.<br>
          
          만약 test가 ['test0', 'test1', 'test2', 'test3']인 상태라고 가정하면<br>
          alert(test.pop());을 실행했을 때 알림으로 test3을 출력한 다음, test에서는 마지막 요소인 'test3'를 삭제하게 되고,<br>
          test는 ['test0', 'test1', 'test2']가 된다.
        </pre>
    </span>
    <span>데이터 삭제 방법 2 (배열의 맨 앞의 요소를 삭제) :<br>
        <pre>
          위의 test라는 배열에서 데이터를 삭제하고 싶을 때에는 test.shift();를 하면 된다.<br>
          그러면 배열에서 가장 처음에 추가된 요소부터 차례대로 삭제된다.<br>

          또한 다른 특징으로 변수명.shift()을 해서 요소를 삭제하면 단순하게 삭제만 되는 것이 아니라 실제로 삭제된 값을 사용할 수 있다.<br>
          
          만약 test가 ['test0', 'test1', 'test2', 'test3']인 상태라고 가정하면<br>
          alert(test.pop());을 실행했을 때 알림으로 test0을 출력한 다음, test에서는 마지막 요소인 'test0'를 삭제하게 되고,<br>
          test는 ['test1', 'test2', 'test3']이 된다.
        </pre>
    </span>
    <span>데이터 정렬 방법 :<br>
        <pre>
          만약 정렬이 되있지 않은 상태의 배열 변수인 sortTest가 있다고 하자.<br>
          sortTest가 ['b', 'c', 'a']라고 했을 때,

          sortTest를 오름차순으로 정렬하려면 sortTest.sort()를 하면 된다.;<br>
          그러면 sortTest는 ["a", "b", "c"]가 된다.<br>

          sortTest를 내림차순으로 정렬하려면 sortTest.reverse()를 하면 된다.;<br>
          그러면 sortTest는 ["c", "b", "a"]가 된다.<br>
        </pre>
    </span>
    <span>데이터 추출 방법 :<br>
        <pre>
            test가 ['test0', 'test1', 'test2' 'test3', 'test4']라고 가정했을 때<br>
            test.slice(start, end)를 하면 배열의 일부를 추출할 수있다. 단, 실제 배열의 값을 수정하진 않는다.<br>
            여기서 주의할 점은 이 때 추출되는 배열은 start에서 end까지가 아니라 start부터 end 사이의 값을 추출한다.<br>

            만약 test.slice(1,3);을 하게 되면 index 번호가 1에서 3까지인 'test1', 'test2' 'test3'이 아니라<br>
            1부터 3 사이인 'test1', 'test2'를 출력하게 된다.<br>
            역순인 test.slice(3,1);은 작동하지 않는다.

            또한 end를 생략하게 되면 start부터 배열의 마지막 요소까지의 모든 요소를 출력한다.<br>
            test.slice(1);을 하게 되면 'test1', 'test2' 'test3', 'test4'가 된다.

            그리고 인자를 -로 주게 되면 배열의 마지막부터 그 개수에 해당하는 요소를 출력한다.<br>
            test.slice(-2);를 하게 되면 'test3', 'test4'를 출력한다.
        </pre>
    </span>
    
    <span>데이터 합치기 방법 :<br>
        <pre>
            만약 내용물이 ['Hello', 'World', '...?']인 joinTest라는 배열이 있다고 가정했을 때<br>
            이 요소들을 하나의 문자열로 만들고 싶다면 join(text);를 사용하면 된다.<br>
            alert(joinTest.join(' '));을 하게 되면 'Hello World ...?'가 출력된다.<br>
            
            단순하게 alert(joinTest)를 하게 되면 각 요소들이 콤마(,)를 통해 합쳐져서 나오지만<br>
            join은 안의 인자인 test에 특정 문자열을 넣어서 해당 문자열로 콤마(,)를 대체해서 출력되게 한다.
        </pre>
    </span>
    <script src="index.js"></script>
</body>
</html>