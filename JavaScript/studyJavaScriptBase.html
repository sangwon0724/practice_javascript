<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 개념 공부</title>
    <link rel="stylesheet" href="../css/index.css" />
</head>
<body>
    <section id="basic">
        <span><bold>기본</bold></span>
        <span>알림 출력 : alert('알림');</span>
        <span>콘솔 출력 : console.log('콘솔'); 만약에 console.log("one",1);이라고 하면 one : 1이라고 출력된다.</span>
        <span>값 입력받기 : prompt('아무 값이나 입력해주세요!');</span>
        <span>Html 파일에 글 추가 : documnet.write("아무 문자");</span>
        <span>형변환 (숫자 → 문자) : String(3); //맨앞이 대문자</span>
        <span>객체의 구조 보기 (key랑 value 등등) : console.dir(객체명);</span>
        <span>콘솔 출력의 그룹화
            <pre>
                console.group('console group test');
                    console.log('a');
                    console.log('b');
                    console.log('c');
                console.groupEnd();
            </pre>
        </span>
    </section>

    

    <section id="mathAndString">
        <span><bold>숫자 및 문자열</bold></span>
        <span>수의 연산 :
            <pre>
                Math.pow(3,2);       //출력 : 9,   3의 2승
                Math.round(10.6);    //출력 : 11,  10.6을 반올림
                Math.ceil(10.2);     //출력 : 11,  10.2를 올림
                Math.floor(10.6);    //출력 : 10,  10.6을 내림
                Math.sqrt(9);        //출력 : 3,   3의 제곱근
                Math.random();       //출력 : 0부터 1.0 사이의 랜덤한 숫자 (소수점 포함)
                Math.round(100*Math.random()+1);       //출력 : 1부터 100 사이의 랜덤한 숫자 (정수)
            </pre>
        </span>
        <span>자료형 확인 : alert(typeof [변수명 또는 숫자 또는 문자열]); //출력 예시 : string 또는 number</span>
        <span>문자열 더하기 : alert("Hello"+" World"); //출력 : Hello World</span>
        <span>문자열 길이 : "Hello World".length//출력 : 11</span>
        <span>문자 위치 구하기 : "code".indexof("c"); //출력 : 0</span>
    </section>

    

    <section id="variable">
        <span><bold>변수</bold></span>
        <span>변수 선언 :
            <pre>
                var f="te"; var b="st"; 또는 var f="te", b="st";
                사용 => alert(f+b); //출력 : test
            </pre>
        </span>
        <span>변수 입력 받기 :
            <pre>
                var name=prompt('당신의 이름은 무엇인가요?');//test 입력
                alert(name);    //출력 : test
            </pre>
        </span>
    </section>

    

    <section id="operator">
        <span><bold>연산자</bold></span>
        <span>== 연산자 사용 (값만 같으면 됨) :
            <pre>
                alert(1 == 2)             //출력 : false
                alert(1 == 1)             //출력 : true
                alert("one" == "two")     //출력 : false
                alert("one" == "one")     //출력 : true
            </pre>
        </span>
        <span>=== 연산자 사용 (조건을 엄격하게 하여 비교 => 값과 자료형이 모두 같아야 됨) :
            <pre>
                alert(1 == '1');          //출력 : true
                alert(1 === '1');         //출력 : false
                alert(null == undefined); //출력 : true
                alert(null === undefined);//출력 : false
                alert(true == 1);         //출력 : true
                alert(true === 1);        //출력 : false
                alert(true == '1');       //출력 : true
                alert(true === '1');      //출력 : false
                alert(0 === -0);          //출력 : true
                alert(NaN === NaN);       //출력 : false
            </pre>
        </span>
        <span>같지 않음을 비교하는 ==와 ===처럼 같지 않음을 비교하는 !=와 !==가 존재한다.
            <pre>
                alert(1 != '1');          //출력 : false
                alert(1 !== '1');         //출력 : true
            </pre>
        </span>
        <span>And를 의미하는 &&와 Or을 의미하는 ||가 있다.</span>
    </section>

    

    <section id="ifElse">
        <span><bold>조건문</bold></span>
        <span>
            <pre>
            if(true){
                alert('result : true');
            }

            if(false){
                alert('result : true');
            }

            if(조건1){
                alert('if 결과');
            }
            else if(조건2){
                alert('else if 결과');
            }
            else {
                alert('else 결과');
            }

            switch ( condition ) {
                case value1:
                statement1;
                break;
                case value2:
                statement2;
                break;
                ...
                default:
                statement3;
            }

            //예시
            var test="test";
            switch ( test ) {
                case "test":
                console.log("test입니다.");
                break;
                case "notTest":
                console.log("notTest입니다.");
                break;
                case "whyTest":
                console.log("whyTest입니다.");
                break;
                default:
                console.log("default입니다.");
                break;
            }
            //출력 : test입니다.
            </pre>
        </span>
        <span>true나 false 대신에 1과 0을 쓸 수는 있지만 ==와 ===같은 것을 보면 실전에서는 그냥 true나 false를 쓰는 것이 낫다.</span>
        <span>조건에 변수명을 넣으면 만약 해당 변수가 비어있지 않다면 true를 비어있다면 false를 반환한다.</span>
    </section>

    

    <section id="loop">
        <span><bold>반복문</bold></span>
        <span>
            <pre>
                for(초기화; 반복조건; 반복이 될 때마다 실행되는 코드){
                    반복할 문장;
                }
                
                //예시
                for(var i = 0; i < 10; i++){
                    document.write(i+' ');
                }

                while(조건)}{
                    반복할 문장;
                }

                //예시
                var i = 0;
                while(i < 10){
                    document.write(i+' ');
                    i++;
                }

                //무한 반복
                while(ture){
                    반복할 문장;
                }

                //반복 제어 - 반복 중지
                for(var i = 0; i < 10; i++){
                    if(i===5){break;}//반복을 중지시키고 for문을 빠져나온다.

                    document.write(i+' ');
                }

                //반복 제어 - 넘기기
                for(var i = 0; i < 10; i++){
                    if(i===5){continue;}//i가 5일 때 반복을 한번 생략하고 다음 반복 (i가 6인 경우)을 진행한다.

                    document.write(i+' ');
                }
            </pre>
        </span>
    </section>

    

    <section id="function">
        <span><bold>함수</bold></span>
        <span>함수 : 하나의 로직을 재실행할 수 있도록 하는 것</span>
        <span>함수의 특징 :
            <pre>
                ● 코드의 재사용성을 높여준다.
                ● 유지보수가 용이하다.
                ● 가독성이 올라간다.
            </pre>
        </span>
        <span>
            <pre>
                &lt; 선언 방법 1 >
                    function 함수명(인자1, 인자2, ...){
                        코드 내용;
                        return 반환값;  //필요시 선언
                    }

                &lt; 선언 방법 2 >
                    var 함수명 = function()(인자1, 인자2, ...){{
                        코드 내용;
                        return 반환값;  //필요시 선언
                    }}

                &lt; 함수 실행 방법 >
                    함수명(인자 존재시 인자 개수만큼 선언);

                &lt; 선언 방법 3 > - 함수 선언과 동시에 실행하는 방법 ( = 익명 함수 ), function의 앞뒤로 ()를 써 준다.
                    (function()(인자1, 인자2, ...){{
                        코드 내용;
                        return 반환값;  //필요시 선언
                    }})();
            </pre>
        </span>
    </section>

    

    <section id="array">
        <span><bold>배열</bold></span>
        <span>배열 (Array) : 연관된 데이터를 모아서 한꺼번에 관리하기 위해서 사용하는 데이터 타입</span>
        <span>선언 방법 1 (배열 선언과 동시에 초기화): 
            <pre>
                var test = ['test0', 'test1', 'test2']; //대괄호를 사용한다.
                이 때 test를 출력하면 모든 요소를 콤마(,)로 구분하여 보여준다.
                alert(test); //출력 : test0,test1,test2
            </pre>
        </span>
        <span>선언 방법 2 (배열 선언과 동시에 초기화): 
            <pre>
                var test = new Array('test0', 'test1', 'test2'); //소괄호를 사용한다.
                이 때 test를 출력하면 모든 요소를 콤마(,)로 구분하여 보여준다.
                alert(test); //출력 : test0,test1,test2
            </pre>
        </span>
        <span>선언 방법 3 (배열만 선언하는 방법): 
            <pre>
                var test = new Array(3);
            </pre>
        </span>
        <span>사용 방법 : 위의 test에서 'test0' 출력 => alert(test[0]);</span>
        <span>배열의 길이 : 변수명.length</span>
        <span>데이터 추가 방법 1 :
            <pre>
                위의 test의 데이터의 개수가 3개이기 때문에 test[3]="test3";를 하게 되면
                test는  ['test0', 'test1', 'test2', 'test3']가 된다.
                대신 이 경우에는 배열이 갖고 있는 데이터의 개수를 알고 있어야 한다.
            </pre>
        </span>
        <span>데이터 추가 방법 2 (배열의 맨 뒤에 요소를 추가):
            <pre>
                위의 test라는 배열의 맨 뒤에 데이터를 추가하고 싶을 때에는 test.push("test3");를 하면 된다.
                하지만 이 경우에는 배열이 갖고 있는 데이터의 개수를 알고 있지 않아도 된다.
            </pre>
        </span>
        <span>데이터 추가 방법 3 (배열의 맨 앞에 요소를 추가):
            <pre>
                위의 test라는 배열의 맨 앞에 데이터를 추가하고 싶을 때에는 test.unshift("test-1");를 하면 된다.
                하지만 이 경우에는 배열이 갖고 있는 데이터의 개수를 알고 있지 않아도 된다.
            </pre>
        </span>
        <span>데이터 추가 방법 4 (배열의 중간에 요소를 추가):
            <pre>
                위의 test라는 배열의 중간에 데이터를 추가하고 싶을 때에는 test.splice(index, count, element...);를 하면 된다.
                만약 test에서 2번째에 요소를 3개 추가하고 싶다면 test.splice(2, 0, 'test-s-1', 'test-s-2', 'test-s-3');가 된다.
                실행하면 test는 ["test0", "test1", "test-s-1", "test-s-2", "test-s-3", "test2"]가 된다.
                
                이 때 splice의 인자에서 index는 요소가 추가되기 시작할 번호를 의미한다.
                여기서 index는 말 그대로 index기 때문에 2번째라는게 1,2번째의 2번째가 아니라 배열의 0,1,2의 2번째다.
                count는 index로부터 삭제될 요소의 개수를 의미한다. 만약 0을 선언하면 아무 것도 삭제하지 않고 추가한다.
                
                만약 test.splice(2, 1, 'test-s-1', 'test-s-2', 'test-s-3');를 하면 test는 ["test0", "test1", "test-s-1", "test-s-2", "test-s-3"]가 된다.
                이 때 test.splice의 count 인자를 통해 삭제된 인자는 실제로 사용 가능한 값이다.
                그래서 만약 alert(test.splice(2, 1, 'test-s-1', 'test-s-2', 'test-s-3'));를 하면 삭제되는 값들이 출력된다.
                삭제되는 요소가 2개 이상이면 콤마(,)를 통해 연결되서 출력된다.
            </pre>
        </span>
        <span>데이터 추가 방법 5 (배열 합치기):
                <pre>
                위의 test라는 배열말고 추가로 example이라는 배열이 있다고 가정해보자.
                만약 example이 ['example0','example1','example2']라고 했을 때
                test에 example의 요소를 합치고 싶을때는 어떻할까?

                바로 concat이라는 함수를 이용하면 된다.

                test=test.concat(example); 또는 test=test.concat(['example0','example1','example2']);처럼 사용한다.
                그러면 test에 test의 뒤에 example의 요소들을 붙인 배열이 되어 저장된다. (결과 : ["test0", "test1", "test2", "example0", "example1", "example2"])
            </pre>  
        </span>
        <span>데이터 삭제 방법 1 (배열의 맨 뒤의 요소를 삭제) :
            <pre>
                위의 test라는 배열에서 데이터를 삭제하고 싶을 때에는 test.pop();를 하면 된다.
                그러면 배열에서 가장 마지막에 추가된 요소부터 차례대로 삭제된다.

                또한 다른 특징으로 변수명.pop()을 해서 요소를 삭제하면 단순하게 삭제만 되는 것이 아니라 실제로 삭제된 값을 사용할 수 있다.
                
                만약 test가 ['test0', 'test1', 'test2', 'test3']인 상태라고 가정하면
                alert(test.pop());을 실행했을 때 알림으로 test3을 출력한 다음, test에서는 마지막 요소인 'test3'를 삭제하게 되고,
                test는 ['test0', 'test1', 'test2']가 된다.
            </pre>
        </span>
        <span>데이터 삭제 방법 2 (배열의 맨 앞의 요소를 삭제) :
            <pre>
                위의 test라는 배열에서 데이터를 삭제하고 싶을 때에는 test.shift();를 하면 된다.
                그러면 배열에서 가장 처음에 추가된 요소부터 차례대로 삭제된다.

                또한 다른 특징으로 변수명.shift()을 해서 요소를 삭제하면 단순하게 삭제만 되는 것이 아니라 실제로 삭제된 값을 사용할 수 있다.
                
                만약 test가 ['test0', 'test1', 'test2', 'test3']인 상태라고 가정하면
                alert(test.pop());을 실행했을 때 알림으로 test0을 출력한 다음, test에서는 마지막 요소인 'test0'를 삭제하게 되고,
                test는 ['test1', 'test2', 'test3']이 된다.
            </pre>
        </span>
        <span>데이터 정렬 방법 :
            <pre>
                만약 정렬이 되있지 않은 상태의 배열 변수인 sortTest가 있다고 하자.
                sortTest가 ['b', 'c', 'a']라고 했을 때,

                sortTest를 오름차순으로 정렬하려면 sortTest.sort()를 하면 된다.
                그러면 sortTest는 ["a", "b", "c"]가 된다.

                sortTest를 내림차순으로 정렬하려면 sortTest.reverse()를 하면 된다.
                그러면 sortTest는 ["c", "b", "a"]가 된다.
            </pre>
        </span>
        <span>데이터 추출 방법 :
            <pre>
                test가 ['test0', 'test1', 'test2' 'test3', 'test4']라고 가정했을 때
                test.slice(start, end)를 하면 배열의 일부를 추출할 수있다. 단, 실제 배열의 값을 수정하진 않는다.
                여기서 주의할 점은 이 때 추출되는 배열은 start에서 end까지가 아니라 start부터 end 사이의 값을 추출한다.

                만약 test.slice(1,3);을 하게 되면 index 번호가 1에서 3까지인 'test1', 'test2' 'test3'이 아니라
                1부터 3 사이인 'test1', 'test2'를 출력하게 된다.
                역순인 test.slice(3,1);은 작동하지 않는다.

                또한 end를 생략하게 되면 start부터 배열의 마지막 요소까지의 모든 요소를 출력한다.
                test.slice(1);을 하게 되면 'test1', 'test2' 'test3', 'test4'가 된다.

                그리고 인자를 -로 주게 되면 배열의 마지막부터 그 개수에 해당하는 요소를 출력한다.
                test.slice(-2);를 하게 되면 'test3', 'test4'를 출력한다.
            </pre>
        </span>
        <span>데이터 합치기 방법 :
            <pre>
                만약 내용물이 ['Hello', 'World', '...?']인 joinTest라는 배열이 있다고 가정했을 때
                이 요소들을 하나의 문자열로 만들고 싶다면 join(text);를 사용하면 된다.
                alert(joinTest.join(' '));을 하게 되면 'Hello World ...?'가 출력된다.

                단순하게 alert(joinTest)를 하게 되면 각 요소들이 콤마(,)를 통해 합쳐져서 나오지만
                join은 안의 인자인 test에 특정 문자열을 넣어서 해당 문자열로 콤마(,)를 대체해서 출력되게 한다.
            </pre>
        </span>
    </section>

    
    
    <section id="object">
        <span><bold>객체</bold></span>
        <span> 객체 : index 번호로 요소를 꺼내오던 배열과 다르게 key 값이라는 문자열을 통하여 값을 꺼내오는 연관된 데이터들을 한꺼번에 관리하기 위해 사용하는 데이터형</span>
        <span>객체 생성 방법 1 (선언한 후에 초기화) :
            <pre>
                예시 : var grade = {};     //중괄호를 사용한다.
                grade['a']=1; grade['b']=2; grade['c']=3; //대괄호 안에 키 값을 표현한 후 값을 대입한다.
            </pre>
        </span>
        <span>객체 생성 방법 2 (선언과 동시에 초기화) :
            <pre>
                예시 : var grade = {'a' : 1, 'b' : 2, 'c' : 3};     //중괄호를 사용한다.
            </pre>
        </span>
        <span>객체 사용 방법 (단순 사용)
            <pre>
                alert(grade['a']);  //출력 : 1
            </pre>
        </span>
        <span>객체 사용 방법 (for문 사용 - 타 언어의 forEach 방식)
            <pre>
                var forEachTest = {'a' : 1, 'b' : 2, 'c' : 3};
                for(keyName in forEachTest) {
                    console.log("keyName : "+keyName+" value : "+forEachTest[keyName]+"&lt;br />");
                }
                
                keyName은 객체의 key 값을 처음부터 마지막까지 차례대로 읽어온다 (keyName은 직접 지정한 별칭, 자유지정 가능).
                forEachTest에는 내가 for문으로 읽어들일 객체의 실제 이름을 명시하면 된다.
            </pre>
        </span>
        <span>객체 지향 프로그래밍
            <pre>
                객체에는 배열이나 함수도 선언할 수 있다.

                var studentInfo={
                    'grade' : {'bule' : 1, 'yellow' : 2, 'red' : 3},
                    'class' : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                    'functionTest' : function(){
                        for(var name in this.grade){
                            console.log('name : ' + name + ', value : ' + this.grade[name] + "\n")
                        }
                    }
                };

                접근 방식 1 => 만약 grade의 bule에 접근하고 싶으면 studentInfo['grade']['blue']를 하면 된다.
                접근 방식 2 => 만약 class의 3번 인덱스에 접근하고 싶으면 studentInfo['class'][3]을 하면 된다.
                접근 방식 3 => 만약 객체의 내부에서 특정 키 값에 접근하고 싶다면 this.KEY이름을 하면 된다.
                접근 방식 4 => 만약 객체의 내부에 선언한 함수를 사용하고 싶다면
                            위의 경우에는 studentInfo.functionTest();를 하거나, studentInfo['functionTest']();를 하면 된다.
            </pre>
        </span>
        <span>객체의 독립성
            <pre>
                ● 객체는 원시 데이터 변수와 다르게 같은 데이터를 가졌어도 다르게 취급한다.
                    예시)
                        var a1 = {test : 1};
                        var a2 = {test : 1};
                        console.log(a1===a2);   //출력 : false

                ● 하지만 객체 내의 데이터를 비교하면 정상적으로 비교가 가능하다.
                    예시)
                        var a1 = {test : 1};
                        var a2 = {test : 1};
                        console.log(a1.test===a2.test);   //출력 : true

                ● 객체는 원시 데이터처럼 복사가 불가능하다.
                    예시)
                        var a1 = {test : 1};
                        var a2 = a1; //객체는 복사가 아니라 참조를 한다.
                        a2.test=2;  //a2의 test를 변경
                        console.log(a1.test);   //출력 : 2, a2의 test를 변경했지만 a1의 test도 변경된다.

                ● 객체의 복사를 위해서는 Object.assign() 메소드를 사용하면 된다.
                    예시)
                        var a1 = {test : 1};
                        var a2 = Object.assign({},a1); //Object.assign() 메소드는 {} 안의 데이터들과 뒤에 따라오는 이름들에 해당되는 객체들의 데이터들을 합쳐서 하나의 객체로 만들어준다.
                        a2.test=2;  //a2의 test를 변경
                        console.log(a1.test);   //출력 : 1
                        console.log(a2.test);   //출력 : 2
                    문제점)
                        Object.assign()은 property를 복사하는 것이기 때문에 만약 복사되는 값이 array나 object라면 복사가 되는 것이 아니라 그 객체들에 한해서 참조가 된다.

                ● 객체 복사시 내부의 객체에 대한 문제점 해결 방법
                    예시)
                        var a1 = {test1 : 1, test2 : [1,2]};
                        var a2 = Object.assign({},a1);
                        a2.test2.push(3);
                        console.log(a1.test2);   //출력 : [1,2,3], 이유 : 객체를 복사할 때 객체 안의 객체는 복사가 아니라 참조가 된다.
                        a2.test2 = a2.test2.concat(); //기존에 갖고 있던 내용을 복사해서 메모리 안의 새로운 위치를 가리키게 한다.
                        a2.test2.push(4);
                        console.log(a1.test2); //출력 : [1,2,3]
                        console.log(a2.test2); //출력 : [1,2,3,4]
            </pre>
        </span>
    </section>

    

    <section id="module">
        <span><bold>모듈</bold></span>
        <span>모듈화 : 하나의 코드를 여러 개의 파일로 분리하는 작업
            <pre>
                1. 자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 재활용이 가능하다.
                2. 코드를 개선하면 이를 사용하는 모든 애플리케이션의 동작이 개선된다.
                3. 코드 수정 시에 필요한 로직을 빠르게 찾을수 있다. 
                4. 필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다. 
                5. 한 번 다운로드 된 모듈은 웹 브라우저에 의해서 저장되기 때문에 동일한 로직을 로드 할 때
                시간과 네트워크 트래픽을 절약할 수 있다. (브라우저에서만 해당) 
            </pre>
        </span>
        <span>모듈화 방법 (기본) :
            <pre>
                만약 index.html의 script 태그 안에
                function returnHelloWorld(){
                    return "Hello World";
                }
                alert(returnHelloWorld());
                라는 기본적인 javascript 코드가 있다고 치자,

                지금은 매우 기본적인 짧고 간단한 코드지만 코드의 양이 많아지게 된다면 코드의 활용성과 가독성이 떨어지게 된다.
                
                그렇기 때문에 returnFunction.js같은 연관되 있는 기능들을 한 곳에 모아둘수 있는 특정 파일을 새로 만들어서
                그 파일에 따로 선언해둔 다음에 index.html에 와서 script 태그의 src 속성으로 returnFunction.js를 연결해서 사용한다.

                그렇게 되면 returnFunction.js에는 연관된 기능들끼리만 모여있기 때문에 편리성과 재활용성과 가독성이 좋아지게 되며
                이 경우에서의 index.html의 script 코드에는 alert(returnHelloWorld());만 남기 때문에 코드가 매우 간결해지는 효과를 얻게 된다. 
            </pre>
        </span>
    </section>

    

    <section id="regularExpression">
        <span><bold>정규 표현식</bold></span>
        <span>정규 표현식 : 문자열에서 특정한 문자를 찾아내는 도구</span>
        <span>정규 표현식을 사용하기 위한 편의성을 제공해주는 사이트 목록 :
            <pre>
                1. <a href="https://regexper.com/">https://regexper.com/</a> : 정규 표현식을 시각화해서 보여주는 사이트
                2. <a href="http://gskinner.com/RegExr/">http://gskinner.com/RegExr/</a> : 정규 표현식을 실시간으로 테스트해볼 수 있는 사이트
                3. <a href="http://www.regexr.com/">>http://www.regexr.com/</a> : 정규 표현식에 대한 도움말과 테스트 도구들을 제공하는 사이트 
            </pre>
        </span>
        <span>정규 표현식 생성 방법의 종류 :
            <pre>
                1. 컴파일 : 검출하고자 하는 패턴을 만드는 단계, 정규 표현식 객체를 만들어야 한다.
                2. 실행 : 컴파일 단계에서 만든 정규 표현식 객체를 통해서 특정 문자열을 검출하는 단계
            </pre>
        </span>
        <span>정규 표현식 - 컴파일 단계 :
            <pre>
                방법은 두 가지가 있으며, 두 가지 모두 같은 결과를 만들지만 각자가 가진 장단점이 다르다.

                ▶ 정규 표현식 리터럴
                    var pattern = /찾을 문자/;
                ▶ 정규 표현식 객체 생성자
                    var pattern = new RegExp('찾을 문자');
                ▶ 정규 표현식의 특수 기호
                    . : 문자 한 자리를 의미한다.
            </pre>
        </span>
        <span>정규 표현식 - 실행 단계 :
            <pre>
                기본 조건 : var pattern = /a/;

                ▶ RegExp.exec(문자열)
                    console.log(pattern.exec('abcdef'));   //출력 : ["a"], 이유 : 정규 표현식에서 표현한 a가 존재하기 때문에, 배열을 반환한다.
                    console.log(pattern.exec('bcdef'));    //출력 : null, 이유 : 정규 표현식에서 표현한 a가 존재하지 않기 때문에
                ▶ RegExp.test(문자열)
                    console.log(pattern.test('abcdef'));   //출력 : true, 이유 : 정규 표현식에서 표현한 a가 존재하기 때문에
                    console.log(pattern.test('bcdef'));    //출력 : null, 이유 : 정규 표현식에서 표현한 a가 존재하지 않기 때문에
                </pre>
        </span>
        <span>정규 표현식 - 문자열 메소드 :
            <pre>
                기본 조건 : var pattern = /a/;

                ▶ String.match(객체명)
                    RegExp.exec(문자열)와 비슷하다.

                    console.log('abcdef'.match(pattern));   //출력 : ["a"], 이유 : 정규 표현식에서 표현한 a가 존재하기 때문에, 배열을 반환한다.
                    console.log('bcdef'.match(pattern));    //출력 : null, 이유 : 정규 표현식에서 표현한 a가 존재하지 않기 때문에
                ▶ String.replace(객체명, 교체 문자열)
                    console.log('abcdef'.replace(pattern, 'A'));   //출력 : Abcdef
                    console.log('abcdefa'.replace(pattern, 'A'));   //출력 : Abcdefa, 맨 앞 글자만 바뀐다.
            </pre>
        </span>
        <span>정규 표현식 - 옵션 :
            <pre>
                기본 조건 : var pattern = /a/;

                ▶ i 옵션 : 대소문자를 구분 하지 않는다.
                    var p = /a/;
                    var pI = /a/i;

                    console.log('Abcdef'.match(p));   //출력 : null, 이유 : 대소문자를 구분하기 때문에 A는 안되고 a만 가능하다.
                    console.log('Abcdef'.match(pI));  //출력 : ["a"], 이유 : 대소문자를 구분하지 않기 때문에 i 옵션으로 인해 a도 A도 가능하다.
                ▶ g 옵션 (Global): 검색된 모든 결과를 리턴한다.
                    var p = /a/;
                    var pG = /a/g;
        
                    console.log('abcdef'.match(p));   //출력 : ["a"], 이유 : 정규 표현식에 맞는 첫 번째 결과만 출력한다.
                    console.log('abcdefa'.match(pG));  //출력 : ["a","a"], 이유 : 정규 표현식에 맞는 모든 결과를 출력한다.
                ▶ 옵션은 동시에 사용 가능하다
                    var pIG = /a/ig;
        
                    console.log('abcdefA'.match(pIG));   //출력 : ["a","A"]
            </pre>
        </span>
        <span>정규 표현식 - 캡쳐 :
            <pre>
                ▶ 괄호 안의 패턴은 마치 변수처럼 재사용 할 수 있다. ($ 기호 사용)
                    var pattern = /(\w+)\s(\w)/;
                    var str = "Hello World";
                    var result = str.replace(pattern, "$2 ~ $1");
                    console.log(result);    //출력 : World ~ Hello
                    //이유 : $는 정규 표현식에서 그룹을 나타낸다. (배열처럼 0부터가 아니라 1부터 사용)
                    그래서 $2와 $1을 위치를 바꾸는 표현식을 나타냈기 때문에 저렇게 바뀌는 것이다.
            </pre>
        </span>
        <span>정규 표현식 - 치환 :
            <pre>
                var urlPattern = /\b(?:https?):\/\/[a-z0-9-+&@#\/%?=~_|!:,.;]*/gim;
                var content = '네이버의 홈페이지 주소는 http://naver.com 입니다.';
                var result = content.replace(urlPattern, function(url){
                    return '<a href="'+url+'">'+url+'</a>';
                });
                console.log(result);
                //출력 : "네이버의 홈페이지 주소는 <a href="http://naver.com">http://naver.com</a> 입니다."
                //이유 : replace의 첫번째 인자는 정규 표현식 객체명이다. 그리고 평소대로라면 두 번째 인자는 교체할 문자열이다.
                //       그런데 만약 replace의 두 번째 인자를 인자를 받는 함수로 선언하면,
                //       패턴에 맞는 문자열이 있을 때 해당 문자열이 자동으로 함수의 인자로 들어가도록 약속되어있기 떄문이다.
            </pre>
        </span>
        <span>정규 표현식 - 패턴 (역슬래시 + 문자):
            <pre>
                1. \w : A ~ Z, a ~ z, 0 ~9 모두 포함
                2. \s : 공백 (White Space)
            </pre>
        </span>
        <span>정규 표현식 - 패턴 (기호):
            <pre>
                1. () : 그룹화
                2. + : 앞의 것이 하나 이상인 경우, 패턴이 만약 \w+라면 문자열이 '#'이면 실패, 'abc'면 성공이다.
            </pre>
        </span>
    </section>

    

    <section id="functionOriented">
        <span><bold>함수 지향</bold></span>
        <span>변수의 유효 범위
            <pre>
                ▶ 전역 변수 : 에플리케이션 전역에서 접근이 가능한 변수
                ▶ 지역 변수 : 함수 내부에서 사용하는 제한적인 변수
            </pre>
        </span>
        <span>선언에 따른 변수의 유효 범위 변화
            <pre>
                var varScope = 'global';
                function scopeTest(){
                    varScope = 'local';
                    alert(varScope);//출력 : local, 이유 : varScope의 값이 local로 초기화 되었기 때문에
                }
                scopeTest();
                alert(varScope);//출력 : local, scopeTest 함수 안에서 varScope 앞에 var가 붙지 않았기 때문에 전역변수 취급받기 때문이다.

                즉, 변수를 초기화할 때에는 (특히, 함수 내부에서 초기화할 때) var같은 자료형을 붙이는 것을 습관화 해야 한다.
            </pre>
        </span>
        <span>유효 범위를 신경써야 되는 이유
            <pre>
                var resultA=0, resultB=0;
                function a (){
                    i=0;       //전역 변수의 경우
                }
                function b (){
                    var i = 0; //지역 변수의 경우
                }
                for(var i = 0; i &lt; 5; i++){
                    a();    //전역 변수의 경우
                    resultA+=i;
                }
                for(var i = 0; i &lt; 5; i++){
                    b();    //지역 변수의 경우
                    resultB+=i;
                }
                console.log("결과 A : " + resultA);     //출력 : 0, 애초에 무한 반복이라 사실 결과 안 나옴
                console.log("결과 B : " + resultB);     //출력 : 10

                기본 전제 : for문을 돌렸을 때 i가 var를 통해 선언된다. 즉, for문의 조건에 있는 i가 전역변수
                resultA가 0이 나오는 이유 :
                    var를 붙이지 않고 변수를 선언하면 전역변수가 된다.
                    for문의 조건식에서 돌아가는 i를 for문 내부의 a()에서 전역변수 상태로 계속 0으로 초기화시키기 때문에
                    계속 무한 루프를 시킨다.
                resultB가 10이 나오는 이유 :
                    for문 내부의 b()에서 초기화 되는 i는 var를 붙였기 때문에 b() 내부에서만 사용되는 아예 다른 i다.
                    그렇기 때문에 for문이 정상적으로 작동해서 결과값이 10이 된 것이다.
            </pre>
        </span>
        <span>전역 변수 사용법
            하나의 객체를 전역 변수로 만들고 객체의 속성으로 변수를 관리한다.
            <pre>
                studentInfo = {};
                studentInfo.score = {
                    "korea" : null,
                    "english" : null,
                    "math" : null
                };
                studentInfo.personal = {
                    "name" : null,
                    "age" : null,
                    "grade" : null,
                    "class" : null,
                    "no" : null
                }

                사용 => studentInfo.score.math = 90;
            </pre>
        </span>
        <span>유효 범위의 대상
            <pre>
                for(var i = 0; i &lt; 5; i++){
                    var name="test name";
                }
                alert(name);    //출력 : test name

                위의 코드를 진행한 후에

                testFunction=function(){var name="test name?";};
                testFunction();
                alert(name);    //출력 : test name, 이유 : var에 의한 전역변수/지역변수 구분은 함수의 내외에서만 구분된다. 그 외에는 항상 전역변수
            </pre>
        </span>
        <span>정적 유효 범위 : 자바스크립트의 함수가 선언된 시점에서의 유효 범위 ( = 정적 유효 범위, 렉시컬)
            <pre>
                var i = 5;
                function a(){
                    var i = 10;
                    b();
                }
                function b(){
                    console.log(i);
                }
                a();
                
                이렇게 코드가 있을 때 결과는 어떻게 되는가?
                5가 출력 된다.
                왜냐하면 언뜻보면 a()가 실행되고 그 안에서 b()가 실행되어서 i가 10이 될 것 같지만
                b()는 자신의 내부의 코드에서 사용하는 i가 자신의 인자에 있는지 먼저 살펴본 다음에,
                존재하지 않을 경우에는 자신이 호출됬을 때가 아닌 자신이 정의 됬을 때의 i의 값인 5를 가져오게 된다.
                이렇게 자신이 호출됬을 때가 아닌 자신이 정의 됬을 때의 값을 가져오게 되는 것을 정적 유효 범위라고 한다.
            
                ▶ 실험 1 : a() 내부의 b()가 b(i)고, b()는 그대로 b()인 경우
                ▶ 결과 1 : 5 출력

                ▶ 실험 1 : a() 내부의 b()가 b(i)고, b()도 b(i)인 경우 => 보통의 프로그래밍
                ▶ 결과 1 : 10 출력
            </pre>
        </span>

        <hr>

        <span><bold>함수 지향 - 값으로서의 함수와 콜백 함수</bold></span>
        <span>값으로서의 함수 : JavaScript에서는 함수도 객체이기 때문에 일종의 값이 될 수 있음을 의미한다.
            <pre>
                function test(){}는 var test = function(){};와 같다.
            </pre>
        </span>
        <span>메소드 : 객체의 속성 값으로 담겨진 함수
            <pre>
                var testA = function(){};

                var testB = {
                    subject : function(){
                        console.log('execute test.subject()');
                    }
                };
            </pre>
        </span>
        <span>함수의 값으로서의 전달 방법
            <pre>
                //문자열을 만드는 함수
                function printTest(func, num){
                    return num + '의 제곱은 ' + func(num) + '입니다.';
                }

                //제곱의 결과를 반환하는 함수
                function squaredTest(num){
                    return num*num;
                }

                //함수를 실행하여서 결과 출력
                console.log(printTest(squaredTest,3));   //출력 : 3의 제곱은 9입니다.
                //이유 : printTest의 return에 보면 사용하는 인자 중 func의 뒤에 (num)이 붙어있다.
                //       이는 해당 인자를 함수로 사용하겠다는 JavaScript의 문법이다.
                //       그래서 이대로 실행하게 되면 func라는 인자에는 squaredTest(num)라는 함수가 들어가서
                //       num이라는 인자를 받아서 실행한 뒤에 차례대로 리턴하여서 마지막에는 결과값으로 문자열을 리턴해주게 된다.
            </pre>
        </span>
        <span>리턴 값으로서의 함수 사용
            <pre>
                function cal(mode){
                    var funcs = {
                        'plus' : function(left, right){return left + right},
                        'minus' : function(left, right){return left - right}
                    }
                    return funcs[mode];
                }
                alert(cal('plus')(2,1));
                alert(cal('minus')(2,1));

                //실행 과정
                //0. 가정 : alert(cal('plus')(2,1));를 실행
                //1. 먼저, cal('plus') 실행된다.
                //2. cal 함수를 통해서 funcs['plus']라는 배열의 데이터가 리턴된다.
                //   이 때, func['plus']는 function(left, right){return left + right}라는 함수를 값으로 전달하게 된다.
                //3. 값으로 함수를 반환하는 것 이전에 함수는 변수의 속성이 될 수 있다고 하였다.
                //   즉, funcs['plus']= function(left, right){return left + right}가 된다.
                //   JavaScript의 기본적인 함수 모양으로 바꾸면 아래의 코드처럼 바뀐다.
                //   function funcs['plus'](left, right){
                //       return left + right;
                //    }
                //   그저 함수의 이름이 test나 example이 아니라 funcs['plus']가 됬을 뿐이다.
            </pre>
        </span>
        <span>배열로서의 함수 사용
            <pre>
                var process = [
                    function(input){ return input + 10;},
                    function(input){ return input * input;},
                    function(input){ return input / 2;}
                ];
                var input = 1;
                for(var i = 0; i &lt; process.length; i++){
                    input = process[i](input);
                }
                alert(input);   //출력 : 60.5, 이유 : 1 → 11 → 121 → 60.5
            </pre>
        </span>
        <span>정렬하기, sort 메소드는 return 값이 음수/0/양수인지에 따라서 순서를 바꾼다.
            <pre>
                function sortNumberAmB(a,b){
                    return a-b;
                }
                function sortNumberBmA(a,b){
                    return b-a;
                }
                
                var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];

                alert(numbers.sort(sortNumberAmB));
                // array, [1,2,3,4,5,6,7,8,9,10,20] => 비교 함수 (a, b)의 결과 값이 음수면 a가 앞으로 간다.

                alert(numbers.sort(sortNumberBmA));
                // array, [20,10,9,8,7,6,5,4,3,2,1] => 비교 함수 (a, b)의 결과 값이 음수면 b가 앞으로 간다.
                
                //0인 경우에는 해당 요소를 제외한 다른 모든 데이터들에 대해서 정렬한다.
            </pre>
        </span>

        <hr>

        <span><bold>함수 지향 - 클로저</bold></span>
        <span>클로저 (closure) : 내부 함수가 외부 함수의 맥락 (context)에 접근할 수 있는 것
            <pre>
                function test(){}는 var test = function(){};와 같다.
            </pre>
        </span>
        <span>내부 함수 : 함수 안에서 또 다른 함수를 선언할 수 있는 JavaScript 문법
            <pre>
                function outside(){
                    function inside(){
                        var text = "text";
                        console.log(text);
                    }
                    inside();
                }
                outside();

                //내부 함수는 외부 함수의 지역 변수에 접근할 수 있다.
                //위의 함수를 아래처럼 바꿔도 정상적으로 작동한다.
                //inside(text)로 선언된 것이 아니라 inside()로 인자가 없다고 선언되어있음에도
                //내부 함수이기 때문에 외부 함수의 지역 변수인 text를 사용할 수 있는 것이다.
                function outside(){
                    var text = "text";
                    function inside(){
                        console.log(text);
                    }
                    inside();
                }
                outside();
            
                //또 다른 방식으로도 사용 가능하다.
                function inside(){
                    var text = "text";
                    return function (){ console.log(text); }
                }
                var outside = inside();
                outside();
            </pre>
        </span>
        <span>private variable : 아무나 수정할 수 있는 것을 방지하는 것
            <pre>
                function factory_movie(title){
                    return {
                        get_title : function (){
                            return title;
                        },
                        set_title : function(setTitle){
                            if(typeof setTitle === 'String'){
                                title = setTitle;
                            }
                            else{
                                alert('제목은 문자열이어야 합니다.');
                            }
                        }
                    }//객체 리턴
                }

                ironman = factory_movie('iron'); //실행 1
                
                alert(ironman.get_title()); //실행 2
                
                ironman.set_title('iron man'); //실행 3
                
                alert(ironman.get_title()); //실행 4

                //해설 1 : ironman이라는 전역 변수에 factory_movie(title)을 실행해서 객체로 초기화
                //해설 2 : ironman.get_title()을 사용했더니 'ironman'이 아니라 'iron'이 출력된다. 이룰 수정하려고 한다.
                //해설 3 : ironman의 title을 set_title(setTitle)을 통해서 'ironman'로 변경했다.
                //해설 4 : 정상적으로 'ironman'으로 출력된다.

                //추가 해설 (set_title의 작동에 대한 이해)
                //1, factory_movie(title)에서 title은 factory_movie(title)의 매개 변수가 되는 것이다.
                //2. 이것은 factory_movie라는 함수 안에 title이라는 지역 변수가 있음을 의미한다.
                //3. 클로저(closure)는 내부 함수가 외부 함수의 지역 변수에 접근할 수 있는 것을 의미한다.
                //4. 즉, return으로 반환하는 객체의 내부 함수인 set_title은 factory_movie의 지역 변수인 title에 접근이 가능하다.
            </pre>
        </span>
        <span>클로저 사용시 주의점
            <pre>
                클로저라는 것은 내부 함수가 외부 함수의 지역 변수를 접근할 수 있다는 것이지
                for문의 조건식의 i같은 변수에 바로 접근할 수 있다는 뜻이 아니다.
                만약 for문의 i같은 변수에 바로 접근하고 싶다면 아래와 같이 코드를 작성하면 된다.

                var arr = []
                for(var i = 0; i &lt; 5; i++){
                    arr[i] = function(id) {
                        return function(){
                            return id;
                        }
                    }(i);
                }
                for(var index in arr) {
                    console.log(arr[index]());
                }

                //해설
                //1. 우선, for문이 실행되면 arr[i] = function(id) {...}(i);가 된다.
                //   즉, arr[i]안에 명시된 i를 익명 함수의 id라는 매개 변수로 주어서
                //   함수를 실행하는 것하며 그 결과를 저장한다.
                //2. 현재 익명 함수 안에는 또 다른 익명 함수가 있다.
                //   현재 외부 함수에는 i의 값을 받아 초기화 시킨 id라는 매개 변수가 있다.
                //3. 그렇기 때문에 내부 함수에서 외부 함수의 지역 변수인 id에 접근해서 그 값을 리턴해줄 수 있게 되는 것이다.
            </pre>
        </span>

        <hr>

        <span><bold>함수 지향 - arguments</bold></span>
        <span>arguments : 함수에서 사용된 인자들이 저장되는 유사 배열
            <pre>
                function sumTest(){
                    var i, sum = 0;    
                    for(i = 0; i &lt; arguments.length; i++){
                        console.log(i+' : '+arguments[i]);
                        sum += arguments[i];
                    }   
                    return sum;
                }
                console.log('result : ' + sumTest(1,2,3,4));    //출력 : 10
            </pre>
        </span>
        <span>functionName.length & arguments.length
            <pre>
                함수명.length는 함수에서 선언되 있는 매개 변수의 개수를 의미한다.
                arguments.length는 함수를 실행할 때 실제로 들어온 매개 변수의 개수를 의미한다.

                function twoArg(arg1, arg2){
                    console.log(
                        'twoArg.length', twoArg.length,
                        'arguments', arguments.length
                    );
                }
                twoArg('val1');  //twoArg.length 2 arguments 1
                twoArg('val1', 'val2'); //출력 : twoArg.length 2 arguments 2
                twoArg(); //출력 : twoArg.length 2 arguments 0
            </pre>
        </span>

        <hr>

        <span><bold>함수 지향 - 함수의 호출</bold></span>
        <span>함수는 Function이라는 객체의 인스턴스이기 때문에 Function의 메소드인 Function.apply와 Function.call이라는 메소드들을 상속하고 있다.
            <pre>
                ▶ 기본적인 호출 방법
                    function test(){
                        
                    }
                    test();
                ▶ Function.apply => 메소드명.(함수를 호출하는데 제공될 this의 값 (객체명), 전달될 인수들로 이루어진 배열)
                    만약 function sum(a,b) { return a+b; }라는 함수가 있다면
                    기본적으로는 sum(1,3);으로 호출하겠지만
                    Function의 메소드인 apply를 사용해서
                    sum.apply(null, [1,2]);로 호출할 수도 있다.
                    하지만 null의 경우에는 굳이 apply 보다는 그냥 바로 sum(1, 2);로 호출하는 것이 낫다.

                    var arr1 = {val1:1, val2:2, val3:3};
                    var arr2 = {v1:10, v2:50, v3:100, v4:25};

                    function sum(){
                        var result = 0;
                        for(name in this){
                            result += this[name];
                        }
                        return result;
                    }

                    alert(sum.apply(arr1)) //출력 : 6
                    alert(sum.apply(arr2)) //출력 : 185

                    //해설
                    //1. apply에 arr1나 arr2라는 배열을 넣으면 해당 배열의 데이터들이 실행하는 함수의 인자가 된다.
                    //2. apply의 인자로 넣은 배열은 해당 함수의 this라는 변수의 값이 된다.
                ▶ Function.call => 메소드명.(현재 객체로 사용될 객체명, 인수1, 인수2, ...)
                    apply와 비슷하며, 인자를 넣는 방식만 좀 다르다.
                    call의 경우에는 Java에서 객체를 초기화하는 것이라고 생각하면 편하다.

                    function Product(name, price) {
                        this.name = name;
                        this.price = price;
                    }
                    
                    function Food(name, price) {
                        Product.call(this, name, price);//this라는 객체에 Food의 인자로 받은 name과 price라는 변수를 전달
                        this.category = 'food';
                    }

                    var test=new Food('cheese', 5);
                    console.log(test.name); //출력 : cheeze
            </pre>
        </span>
    </section>

    

    <section id="objectOriented">
        <span><bold>객체 지향 프로그래밍</bold></span>
        <span>객체 지향 프로그래밍 : 프로그래밍 로직을 상태와 동작으로 이루어진 객체로 만들어서, 객체들을 조합하여 프로그램을 만드는 것
            <pre>
                ● 상태 => 변수
                ● 동작 => 함수
            </pre>
        </span>
        <span>추상화 (abstract) : 현실이나 특정한 상황에서 사물이나 개념에 대하여 공통적인 특성이나 속성을 추출하여 단순화시키는 것</span>
        <span>모듈화 : 각 기능들을 다른 것들과 구별될 수 있는 독립적인 기능으로 나누는 것
            <pre>
                ▶ 특징
                    • 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위이다.
                    • 유일한 이름을 가져야 한다.
                    • 독립적으로 컴파일이 가능하다.
                    • 모듈에서 또 다른 모듈을 호출할 수 있다.
                    • 다른 프로그램에서도 모듈을 호출할 수 있다.
                ▶ 종류
                    • 용도가 비슷한 것끼리 묶어놓은 라이브러리 함수, 그래픽 함수
                    • 추상화된 자료, 서브루틴, 프로시저, 객체, 메서드
            </pre>
        </span>
        <span>캡슐화 ( = 은닉화 ) : 내부의 동작 방법은 숨기고, 사용자에게는 사용 방법만을 알려주는 것.
            <pre>
                예시)
                감기약 : 감기에 걸렸을 때 감기약을 먹으면 감기가 낫는 효과가 있는 것을 알려준다.
                        그런데, 감기약이 어떻게 감기를 낫게 해주는지는 먹는 사람이 알 필요는 없다.
                        먹는 사람은 그냥 먹으면 감기가 나을수 있는 지의 정보가 필요할 뿐이다.
            </pre>
        </span>
        <span>인터페이스 : 각각의 기능들이 있을 때, 관련된 부분에 대한 표준이 되는 규격</span>

        <hr>

        <span><bold>객체 지향 - 생성자와 new</bold></span>
        <span>
            <pre>
                ▶ 객체 생성 기본 방법 1
                    var student = {};
                    student.grade = 3;
                    student.classNo = 11;
                    student.info = function(){console.log('grade : ' + this.grade + 'class : ' + this.classNo);};

                ▶ 객체 생성 기본 방법 1
                    var student = {
                        'grade' : 3,
                        'classNo' : 11,
                        'info' :  function(){console.log('grade : ' + this.grade + 'class : ' + this.classNo);}//key-value 형식으로 할 때에는 세미 콜론(;)을 붙이지 않아도 된다.
                    };

                    //this를 명시하면 해당 객체 내부의 변수를 가리킨다. ( )= 객체 자기 자신이 가지고 있는 것을 가리키는 것)
            </pre>
        </span>
        <span>생성자 (constructor) : 객체를 만드는 역할을 하는 함수
            <pre>
                ▶ 생성자의 기본적인 이용 방법
                    function Student(){}

                    var s = new Student();//객체 생성
                    s.grade = 3;
                    s.classNo = 11;
                    s.info = function(){console.log('grade : ' + this.grade + 'class : ' + this.classNo);

                //함수 호출 시 new를 붙이면 새로운 객체를 만든 후에 이를 리턴한다.

                //하지만 위의 방법대로 하면 객체를 만들때마다 각 요소들을 새로 선언해야 되기 떄문에
                //같은 기능들을 사용하는 객체를 만들때에는 효율적이지 않다.
                //그렇기 때문에 this를 사용해서 좀 더 효율적으로 바꾼다.

                ▶ this와 함께 사용
                    function Student(grade, classNo){
                        this.name = name;
                        this.classNo = classNo;
                        this.info = function(){console.log('grade : ' + this.grade + 'class : ' + this.classNo);
                    }
            </pre>
        </span>

        <hr>

        <span><bold>객체 지향 - 전역 객체</bold></span>
        <span>전역 객체 (Global Object)
            <pre>
                ● 전역 객체는 특수한 객체다.
                ● 모든 객체는 전역 객체의 프로퍼티다.
                ● 모든 전역 변수와 전역 함수는 window의 프로퍼티다.

                예시)
                    function test(){console.log('execute function test()')};가 있을 때,
                    보통은 test();로 실행시키지만
                    window.test();로도 실행시킬수 있다.
                    왜냐하면 전역 함수는 window의 프로퍼티이기 때문이다.
                    평소에 window를 쓰지 않아도 호출이 가능한 것은 window를 명시하지 않아도 전역 변수와 전역 함수는 암시적으로 window의 프로퍼티로 인식되기 때문이다.
            </pre>
        </span>

        <hr>

        <span><bold>객체 지향 - this</bold></span>
        <span>함수와 this
            <pre>
                ● this는 함수 내에서 함수 호출 맥락(context)를 가리킨다.
                ● 맥락이란 것은 상황에 따라 달라지기 떄문에, 함수를 어떻게 호출하느냐에 따라서 this가 가리키는 대상이 달라진다.
            
                예시)
                    function test(){
                        if(window === this){
                            console.log("window === this");
                        }
                        else{
                            console.log("window !== this");
                        }
                    }
                    test(); //출력 : window === this;
            </pre>
        </span>
        <span>메소드와 this
            <pre>
                ● 객체의 소속인 this는 그 객체를 가리킨다.

                예시)
                    var t={
                        test : function (){
                            if(t === this){
                                console.log("t === this");
                            }
                            else{
                                console.log("t !== this");
                            }
                        }
                    }
                    t.test(); //출력 : t === this;
            </pre>
        </span>
        <span>생성자와 this
            <pre>
                var funcThis = null; 
    
                function Func(){
                    funcThis = this;
                }

                var A = Func();
                if(funcThis === window){
                    console.log('window');
                }//출력 : window
                
                var B = new Func();
                if(funcThis === B){
                    console.log('B');
                }//출력 : B

                ● new를 붙이지 않으면 window의 전역 함수이기 때문에 window가 this가 된다.
                ● new를 붙이면 객체를 리턴하기 때문에 해당 객체가 this가 된다.
            </pre>
        </span>
        <span>객체로서의 함수
            <pre>
                기본적으로 함수를 만들때에는
                function sum(x, y){return x+y;}처럼 만든다.

                하지만 이것은 사실
                var sum = new Function('x', 'y', 'return x+y;');처럼
                new를 통해서 Function이라는 생성자 함수를 불러내서 만드는 것이다.

                그렇지만 이런 식으로 모든 인자와 본문 내용을 저렇게 표현하면 길고 복잡한 코드를 사용할 때 문제가 커지기 때문에
                이렇게 만드는 방식 대신에 특정한 것 (함수나 배열 등)을 문법적으로 표현할 수 있도록 해주는 것을
                리터럴이라고 한다.
            </pre>
        </span>
        <span>apply와 this
            <pre>
                var a = {}
                var b = {}
                function test(){
                    switch(this){
                        case a:
                            console.log('a');
                            break;
                        case b:
                            console.log('b');
                            break;
                        case window:
                            console.log('window');
                            break;          
                    }
                }

                test();         //출력 : window
                test.apply(a);  //출력 : a
                test.apply(b);  //출력 : b
                
                //해설
                //Function.apply => 메소드명.(함수를 호출하는데 제공될 this의 값 (객체명), 전달될 인수들로 이루어진 배열)
            </pre>
        </span>

        <hr>

        <span><bold>객체 지향 - 상속</bold></span>
        <span>상속 (inheritance) : 특정 개체의 로직을 그대로 물려받는 또 다른 객체를 만들수 있는 기능
            <pre>
                ● 단순히 물려받는 것은 의미가 없기 때문에 기존의 로직을 수정해서 파생된 새로운 객체를 만들 수 있게 해준다.

                //기본적인 함수 코드
                function Student(grade, classNo){
                    this.grade = grade;
                    this.classNo = classNo;
                    this.info = function(){console.log('grade : ' + this.grade + ' class : ' + this.classNo)};
                }
                var s = new Student(3, 11);
                s.info();

                //상속을 위한 코드 변경
                function Student(grade, classNo){
                    this.grade = grade;
                    this.classNo = classNo;
                }
                Student.prototype.grade = null;     //protype 초기화
                Student.prototype.classNo = null;   //protype 초기화
                Student.prototype.info = function(){console.log('grade : ' + this.grade + ' class : ' + this.classNo)}; //protype 초기화
                var s = new Student(3, 11);
                s.info();

                //상속 받기
                function Student_Inheritance(grade, classNo){
                    this.grade = grade;
                    this.classNo = classNo;
                }
                Student_Inheritance.prototype = new Student();  //Student_Inheritance의 protype을 통해서 Student를 상속을 받음
                var si = new Student_Inheritance(3, 10);
                si.info();

                //상속을 받은 뒤의 기능 추가
                Student_Inheritance.prototype.hobbyInput = function(){
                    var hobbyInfo = prompt('이 사람의 취미는 무엇입니까?');
                    this.hobby = hobbyInfo;
                    console.log('이 사람의 취미는 ' + this.hobby + '입니다.');
                };
                si.hobbyInput();            //입력 : 게임
                console.log(si.hobby);      //출력 : 게임
            </pre>
        </span>
        <span>JavaScript의 prototype : JavaScript에서 상속을 할 때 사용되는 구체적인 수단
            <pre>
                function GrandParent(){};
                GrandParent.prototype.locationText = 'GrandParent\'s locationText';

                function Parent(){};
                Parent.prototype = new GrandParent();

                function Children(){};
                Children.prototype = new Parent();

                var c = new Children();
                console.log(c.locationText);    //출력 : GrandParent's locationText
            </pre>
        </span>
        <span>prototype chain : 특정 개체의 값을 사용하려 했는데 해당 값이 정의되어 있지 않다면 상속 받은 prototype들을 점점 거슬러 올라가면서 해당 값을 찾아내는 것
            <pre>
                방금 전의 코드를 통해서 console.log(c.locationText);가 실행된 과정을 알아보자.

                1. 우선 c.locationText이기 때문에 c라는 객체에서 locationText라는 값이 정의되있는가를 찾아본다.
                2. c.locationText가 없다면 c의 원형인 Children의 prototype에서 locationText 값이 정의되있는가를 찾아본다.
                3. Children의 prototype에도 locationText이 정의 되어있지 않다면 Children이 상속받은 Parent의 prototype에서 locationText 값이 정의되있는가를 찾아본다.
                4. Parent의 prototype에도 locationText이 정의되어 있지 않다면 Parent가 상속받은 GrandParent의 prototype에서 locationText 값이 정의되있는가를 찾아본다.
                5. GrandParent의 prototype에 locationText가 정의되어 있기 때문에 그 값을 리턴한다.

                이렇게 차례대로 연관되어 거슬러 올라가며 상속받은 protype들을 찾는 것이 prototype chain이다.
            </pre>
        </span>

        <hr>

        <span><bold>객체 지향 - 표준 내장객체의 확장</bold></span>
        <span>표준 내장 객체 (Standard Built-in Object) : JavaScript가 기본적으로 가지고 있는 객체들
            <pre>
                ● 내장 객체가 중요한 이유 : 프로그래밍을 하는데 기본적으로 필요한 도구들이기 때문에
                ● 내장 객체에 대한 이해가 필요한 이유 : 프로그래밍이라는 것은 언어와 호스트 환경에 따라서
                                                    제공하는 기능들을 통해서 새로운 소프트웨어르 만들어내는 것이기 때문에
            </pre>
        </span>
        <span>표준 내장 객체의 종류
            <pre>
                ● Object : 객체
                ● Function : 함수
                ● Array : 배열
                ● String : 문자
                ● Boolean : 참/거짓
                ● Number : 숫자
                ● Math : 수학
                ● Date : 날짜
                ● RegExp : 정규 표현식
            </pre>
        </span>
        <span>배열의 확장
            <pre>
                var arr = new Array('a','b','c','d', 'e');
                function getRandomData(arr){
                    var index = Math.floor(arr.length * Math.random()); //0부터 4까지의 값을 소수점 뒷자리를 제거해서 저장
                    return arr[index];
                }
                console.log(getRandomData(arr));

                //동일한 내용으로 prototype을 통해서 작성해보자.
                Array.prototype.randomTest = function(){
                    var index = Math.floor(this.length * Math.random());
                    return this[index];
                }
                var arr = new Array('a','b','c','d', 'e');
                console.log(arr.randomTest());

                //prototype을 사용한 코드에 대한 해설
                //1. Array라는 내장 객체의 prototype으로 randomTest라는 함수를 생성
                //2. arr이라는 배열을 new를 통해서 Array라는 내장 객체 타입으로 선언하면서 초기화
                //3. arr은 기본적으로 Array라는 내장 객체 타입을 갖고 있기 때문에 처음에 Array의 prototype으로 선언했던 randomTest 함수를 사용 가능하다.
                //4. arr이라는 변수에 할당을 했기 때문에 arr에서 randomTest를 실행시킬 때, randomTest 내부의 this는 window가 아니라 arr이 된다.
                //5. 그 다음에는 차례대로 코드가 진행된 다음에 값을 리턴해준다.
            </pre>
        </span>

        <hr>

        <span><bold>객체 지향 - Object</bold></span>
        <span>Object 객체
            <pre>
                ● 객체의 가장 기본적인 형태를 가지고 있다. ( = 아무것도 상속 받지 않은 순수한 객체 )
                ● JavaScript에서 값을 저장하는 기본적인 단위
                ● JavaScript의 모든 객체는 Object 객체를 상속받는다. ( = 모든 객체는 Object 객체의 프로퍼티를 가지고 있다.)
                ● Object 객체를 확장하면 모든 객체가 접근할 수 있는 API를 만들 수 있다.
            </pre>
        </span>
        <span>Object API
            <pre>
                ▶ JavaScript API 홈페이지 가는 법
                    1. https://developer.mozilla.org/en-US/docs/Web로 이동한다.
                    2. Web technology references이나 Temporary에서 JavaScript 항목을 찾아서 클릭한다.
                    3. References의 Built-in objects에서 Object 항목을 찾아서 클릭한다.
                
                ▶ Object API 사용법
                    사용할 값 1 => var arr = ["a", "b", "c"];
                    사용할 값 2 => var o = {name : 'Tom', 'hobby':'Listen Music'};

                    ● Object.xxx(!!!) 사용법 : Object를 선언한 뒤에 함수명을 명시해서 사용한다.
                        예시 1) console.log(Object.keys(arr));  //출력 : ["0", "1", "2"], 이유 : 배열이기 때문에 키 값으로 index 번호를 리턴한다.
                        예시 2) console.log(Object.keys(o));    //출력 : ["name", "hobby"], 이유 : 객체이기 떄문에 키 값을 리턴한다.
                    ● Object.prototype.yyy(???) 사용법 : 변수명 뒤에 함수명을 명시해서 사용한다.
                        예시 1) console.log(arr.toString());    //출력 : a,b,c
                        예시 2) console.log(o.toString());      //출력 : [object Object]
            </pre>
        </span>
        <span>Object 객체의 확장
            <pre>
                Object.prototype.searchElement = function(searchObject) {
                    for(var index in this){
                        if(this[index] === searchObject){
                            return true;
                        }
                    }
                    return false;
                }
                var student = {name : 'Tom', 'hobby':'Listen Music'};
                console.log(student.searchElement('age'));    //출력 : false
                var number = [1,2,3];
                console.log(number.searchElement(1));         //출력 : true
            </pre>
        </span>
        <span>Object 객체의 확장의 위험성
            <pre>
                만약 위에서럼 Object 객체에 대해서 search라는 함수를 정의했을 때,
                for-in문으로 student와 number를 console.log()로 출력해보면 다음과 같이 나온다. (/는 다음 줄을 의미한다.)
                for(var item in variableName){console.log(item);}

                ● student의 경우 => Tom/Listen Music/searchElement
                ● number 경우 => 1/2/3/searchElement

                심지어 for(var item in variableName){console.log(variableName);}을 하면 searchElement 함수의 코드까지 모두 보여지게 된다.

                이러한 점은 Object 객체에 적용시키면 모든 객체에 적용이 되서 매우 위험하기 때문에 사용하려면 그러한 점을 감안해야 한다.

                물론, 이러한 점을 보완하는 방법은 존재한다.
                원래의 코드인 for(var item in variableName){console.log(item);}에서 약간의 코드를 추가하면 된다.
                for(var item in variableName){
                    if(item.hasOwnProperty(item)){
                        console.log(item);
                    }
                }

                이렇게 하게 되면 student를 예를 들게 되면
                실제 값으로는 Tom/Listen Music만 있지만 Tom/Listen Music/searchElement 출력이 됬었다.
                하지만 hasOwnProperty()는 인자로 들어간 값이 실제로 존재하는 경우에만 true를 반환하기 때문에
                hasOwnProperty()를 사용하게 되면 for-in문을 돌렸을 때 Tom/Listen Music만 나오게 바꿀 수 있다.
            </pre>
        </span>

        <hr>

        <span><bold>객체 지향 - 데이터 타입</bold></span>
        <span>데이터의 타입 : 데이터의 형태
            <pre>
                ▶ 객체인 것 ( = 참조 데이터 타입 )
                    ● Object : 객체
                    ● Function : 함수
                    ● Array : 배열
                    ● String : 문자
                    ● Boolean : 참/거짓
                    ● Number : 숫자
                    ● Math : 수학
                    ● Date : 날짜
                    ● RegExp : 정규 표현식
                ▶ 객체가 아닌 것 ( = 원시 데이터 타입(primitive type), 기본 데이터 타입 )
                    ● 숫자
                    ● 문자열
                    ● true/false
                    ● null
                    ● undefined
            </pre>
        </span>
        <span>레퍼 객체 (wrapper object) : 원시 데이터 타입을 임시로 감싸주는 객체
            <pre>
                사용 변수 => var str = "test";

                ● 질문 : String은 객체인데 문자열은 어째서 객체가 아닐까?
                ● 답변 :
                    1. str에 문자열이 저장될 때는 var str = new String("test");처럼 저장된다고 볼 수 있다.
                    2. JavaScript는 특정 변수에 대한 작업을 진행할 때
                        해당 변수에 저장된 것이 객체 타입이 아니라 원시 데이터 타입이라면
                        임시로 특정한 객체 타입으로 감싸주고 작업을 진행한다.
                        이 때, 원시 데이터 타입을 임시로 감싸주는 객체 타입을 레퍼 객체라고 한다.
                    3. JavaScript에서 레퍼 객체는 해당 변수에 대한 사용이 끝나고 나면 해당 객체를 제거해버린다.

                    예시)
                        var str = "test";
                        str.temp = "temp";
                        console.log(str.temp);  //출력 : undefined

                    4. 예시의 2번째 줄에서 str의 temp 속성에 "temp"라는 값을 넣었다.
                    str.temp에서 .은 정확하게는 객체 접근 연산자라고 하는데 이것은 객체에만 사용이 가능하다.
                    그래서 아까 설명했듯이 str이라는 변수에 .으로 접근 하게 되면
                    str은 new String("test")으로 저장되기 때문에 String 객체 취급이 가능하다.
                    그렇기 때문에 객체에 key-value를 추가하는 것이 가능하기 때문에 오류가 발생하지 않은 것이다.
                    5. 하지만 예시의 3번째 줄에서 console.log(str.temp);를 하면 "temp"가 아니라 undefined가 출력된다.
                    6. 그 이유는 3번에서 설명했듯이 .연산자로 접근하는 당시에는 레퍼 객체가 감싸주기 떄문에
                    객체 취급이라서 key-value의 추가가 가능헀지만 str.temp = "temp";가 끝나면
                    문자열을 감싸주고 있던 레퍼 객체가 사라지기 때문에 선언한 temp 속성이 사라지게 되는 것이다.
                    
                    + plus :
                        원시 데이터 타입 중에서도  숫자, 문자열, true/false은 각각 Number, Stirng, Boolean이 감싸주지만,
                        null, undefined의 경우에는 레퍼 객체가 존재하지 않기 때문에 아까처럼 str.temp같은걸 쓰면 문법 오류가 발생하게 된다.
            </pre>
        </span>

        <hr>

        <span><bold>객체 지향 - 참조</bold></span>
        <span>복제 (copy)
            <pre>
                var a = 1;
                var b = a;
                b = 2;
                console.log(a); //출력 : 2

                //a가 2인 것은 매우 당연하다.
                //왜냐하면 값을 변경한 것은 a가 아니라 b이기 때문이다.
                //b는 a의 값을 복사받은 것이기 때문에 a에는 영향이 없다.
            </pre>
        </span>
        <span>참조 (reference)
            <pre>
                var a = {'id' : 1};
                var b = a;
                b.id = 2;
                console.log(a.id); //출력 : 2

                //평소처럼 복제하듯이 b=a를 해준 다음에 나는 분명 b의 id 값을 변경했는데, a의 id 값도 바뀌었다.
                //그 이유는 변수에 저장된 것이 원시 데이터 타입이면 그 안에는 실제 데이터가 들어가있다.
                //하지만 변수에 저장된 것이 객체 타입이면 그 안에는 참조 방법이 들어가있음을 의미한다.
            </pre>
        </span>
    </section>

    <div id="remote">
        <article id="remote_setcion">
            <select id="remote_menu">
                <option value="basic">기본</option>
                <option value="mathAndString">숫자 및 문자열</option>
                <option value="variable">변수</option>
                <option value="operator">연산자</option>
                <option value="ifElse">조건문</option>
                <option value="loop">반복문</option>
                <option value="function">함수</option>
                <option value="array">배열</option>
                <option value="object">객체</option>
                <option value="module">모듈</option>
                <option value="regularExpression">정규 표현식</option>
                <option value="functionOriented">함수 지향</option>
                <option value="objectOriented">객체 지향</option>
            </select>
        </article>
    </div>

    <script src="./remote.js"></script>
</body>
</html>