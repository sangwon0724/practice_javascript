<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES Series</title>
    <style>
        body {
            background-color: #eeeeee;
        }

        section {
            background-color: white;
        }

        bold {
            font-size: 25px;
            font-weight: bold;
        }

        span {
            display: block;
            margin: 10px 0;
        }

        br {
            margin: 20px 0;
        }
    </style>
</head>

<body>
    <section id="variable">
        <span>
            <bold>변수</bold>
        </span>
        <span>▶ let & const
            <pre>
                ● let : 기존의 var같은 자료형, 변수 재선언 불가, 변수 재할당 가능
                    예시 - var의 경우)
                        var str = "test";
                        var str = "example";//에러 없음
                    예시 - let의 경우)
                        let str = "test";
                        let str = "example";//에러 발생
                ● const : 변수 재선언 불가, 변수 재할당 특정 상황에 한해서 가능
                    예시 - 기본적인 변수의 경우)
                        const str = "test";
                        const str = "example";//에러 없음
                        str = "example";//에러 없음
                    예시 - 객체의 경우)
                        const str = {
                            text : "test"
                        };
                        str.name = "example";//에러 없음

                ※ 기본적인 변수는 왠만하면 const를 쓰고, 재할당할 변수만 let을 하는게 좋다.
            </pre>
        </span>
        <span>▶ Dead Zone
            <pre>
                ● 호이스팅 (Hoisting) : 자바스크립트가 프로그램을 실행하기 전에
                                       var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성
                ● var때문에 생겨나는 호이스팅의 문제점
                    예시) 만약 아래와 같은 코드가 있다고 했을 때
                          console.log(str);
                          var str = "test";
                        
                          자바스크립트는 내부에서 다음과 같이 변환한다.
                          var str;
                          console.log(str);//출력 : undefined
                          str = "test";

                          위의 코드에서는 원래 undefined가 나오면 안된다.
                          원래는 에러가 발생해야 되지만 호이스팅에 의해서 undefined가 발생한다.
                ● let과 const를 써야 하는 이유 :
                    let과 const를 쓰면 위의 코드를 똑같이 사용한다 가정했을 떄
                    이 경우에는 str은 선언하지 않은 변수라고 에러가 발생하게 된다.
            </pre>
        </span>
        <span>▶ Block Scope
            <pre>
                ● let과 const의 경우에는 블록 내부에서만 사용이 가능하다.
                    예시)
                        if(true){ let test = "test";}
                        console.log(test);  //에러 발생
                ● var의 경우에는 블록 내부/외부 상관없이 간섭이 가능하다.
                    예시)
                        if(true){ var test = "test";}
                        console.log(test);  //출력 : test;
                
                ※ 함수의 경우에는 var도 내부/외부 구분이 가능은 하지만 코딩의 실수로 간섭이 발생할수 있기 때문에
                   왠만하면 let과 const를 사용하는 것이 낫다.
            </pre>
        </span>
    </section>

    <br>

    <section id="function">
        <span>
            <bold>함수</bold>
        </span>
        <span>▶ Array.map()
            <pre>
                ● map : 각 요소를 읽는 역할을 한다.
                        인자로 넣은 함수에 각 요소들을 넣으면서 반복한다.
                        반복하면서 실행된 값들은 다시 배열에 모여서 반환된다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        function example(item){return item + "TEST";}
                        const test = somethings.map(example);//test라는 배열에 실행 값들이 저장된다.
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
            </pre>
        </span>
        <span>▶ Arrow Function
            <pre>
                ● 위와 같은 코드를 사용한다고 했을 때 ES6에 추가된 Arrow Function을 사용하면 아래처럼 바뀐다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(item => {
                            return item + "TEST";
                        });
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
                
                ● 하지만 방금의 코드는 기본적인 코드였고, 실제로는 좀 더 간단하게 줄일수 있다. (implicit return : 암시적 리턴)
                  암시적 리턴의 경우에는 {}가 없어야 실행된다. {}를 할 경우에는 undefined를 반환하기 때문에 return을 명시해줘야 한다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(item => item + "TEST");
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]

                ● 또다른 예시 (연산자가 없는 숫자나 문자열로 단순 초기화시 사용, map의 경우)
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(() => item + "TEST");
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
            </pre>
        </span>
        <span>▶ Arrow Function에서의 this
            <pre>
                ● this를 사용해야 하는 상황에서는 Arrow Function을 사용하면 안 된다.
                    예시)
                        addEventListener의 매개 변수 중 함수명을 선언하는 곳에
                        ()=>{console.log(this);}라고 작성한다면
                        현재 이 리스너가 버튼에 적용된다고 가정했을 때
                        출력은 button 태그가 아니라 window가 찍힌다.

                ● 주의점
                    리스너에서 사용할 때 ()=>{console.log(this);}라고 작성하면
                    this는 window를 가리키지만
                    function ()=>{console.log(this);}로 작성하면
                    그 때는 button 태그를 가리킨다.
                    즉, function 예약어의 유무에 따라 this가 가리키는 위치가 달라진다.

                ● 객체에 대한 Arrow Function
                    예시 1)
                        const test = {
                            name : "who",
                            age : 25,
                            addYear : () => {
                                this.age++;
                            }
                        };
                        test.addYear();
                        console.log(test.age);//출력 : 25, 이유 : this가 window를 가리킨다.
                    예시 2)
                    const test = {
                        name : "who",
                        age : 25,
                        addYear(){
                            this.age++;
                        }
                    };
                    test.addYear();
                    console.log(test.age);//출력 : 25, 이유 : this가 객체를 가리킨다.

                    ※ 즉, 객체의 메소드 내부에서 사용하는 this가
                       객체 자신을 가리키게 하고 싶다면 Arrow Function을 사용하면 안된다.
            </pre>
        </span>
        <span>▶ Arrow Function의 실제 사용법
            <pre>
                ● 이메일 찾기 (find : 첫번째 값 반환)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const foundMail = email.find(item => item.includes("@gmail.com"));
                    console.log(foundMail); //출력 : test2@gmail.com

                ● 이메일 필터 (filter : 배열 반환)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const foundMail = email.filter(item => item.includes(".com"));
                    console.log(foundMail); //출력 : ["test1@naver.com", "test2@gmail.com"]

                ● 유저명 저장 (forEach : 반복문)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    email.forEach(
                        test => { console.log(test.split("@")[0]); }
                    );
                    
                ● 유저명 저장 (map : forEach 형식으로 반환된 데이터들을 배열에 저장)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const userNames = email.map(test=>test.split("@")[0]);

                    ※ email.map((test, index) => {name : test.split("@")[0], point : index});처럼 객체로도 반환가능하다.
            </pre>
        </span>
        <span>▶ Default Value (기본 값)
            <pre>
                ● 기본적인 함수의 사용 방법
                    예시)
                        function basicFunction(text){ console.log(text);}
                        basicFunction("test message");//출력 : text message

                ● 값이 없을 경우의 임시 값을 추가하는 방법
                    예시)
                        function noneValueTestFunction(text){ console.log((text || "none value"));}
                        noneValueTestFunction();//출력 : none value

                ● Default Value를 사용하는 방법
                    예시)
                        function defaultValueFunction(text = "default value"){ console.log(text);}
                        defaultValueFunction();//출력 : default value

                ● Default Value와 Arrow Function을 함께 사용하는 방법
                    예시)
                        const defualValueAndArrowFunction = (text = "default value & arrow function") => console.log(text);
                        defualValueAndArrowFunction();//출력 : default value & arrow function
                    
                ※ Default Value는 단순한 텍스트뿐만 아니라 숫자나 변수나 객체 등 뭐든 올수 있다.
            </pre>
        </span>
    </section>

    <br>

    <section id="string">
        <span>
            <bold>문자열</bold>
        </span>
        <span>▶ Template Literal
            <pre>
                ● 기본적인 문자열 합치기
                    const test = (text = "test") => "execute " + text +" !!!";
                    console.log(test());    //출력 : execute test !!!
                    //1. 번거롭다.
                    //2. 헷갈릴 위험도 크다.

                ● 백틱과 함께 쓰기 - 기본편 (` : 물결표랑 같이 있는 기호)
                    const test = (text = "test") => `execute ${text} !!!`;
                    console.log(test());    //출력 : execute test !!!

                ● 백틱과 함께 쓰기 - 응용편 (함수 사용)
                    const add = (a, b) => a + b;
                    const test = (text = "test") => `execute ${add(1, 6)} !!!`;
                    console.log(test());    //출력 : execute 7 !!!
            </pre>
        </span>
        <span>▶ HTML 태그 & Template Literal
            <pre>
                ● 사용법
                    const testDiv = document.getElementById("testDiv");
                    const span = `&lt;span>This is HTML Tag + Template Literal !!!&lt;/span>`;
                    testDiv.innerHTML = span;

                ● 응용법
                    const testArray = ["a", "b", "c"];
                    const testDiv = document.getElementById("testDiv");
                    const list =
                    `&lt;ul>${testArray.map(test => `&lt;li>${test} ★&lt;/li>`).join("")}&lt;/ul>`;
                    testDiv.innerHTML = list;
                
                ※ 백틱(`)은 엔터를 입력하면 엔터도 적용을 시켜준다. ===> &lt;br>을 사용할 필요가 없어진다.
            </pre>
        </span>
        <span>▶ Style을 적용시킨 노드 만들기
            <pre>
                ● css를 적용시킨 태그를 반환하는 방법
                    예시)
                        const settingStyle = newElement =>{
                            const newEle = document.createElement(newElement);//신규 태그 생성

                            return args = (text ="test text", styleArray) => {
                                const settingStyleOptions = styleArray;  //css로 적용할 값들을 불러와서 저장
                                newEle.style = settingStyleOptions;   //태그에 css 적용
                                newEle.innerHTML = text;
                                return newEle;  //태그 반환
                            };
                        };

                        const title = settingStyle("h1")("hmm",`
                            color : white;
                            background-color : blue;
                            font-weight : bold;
                        `);
                        //해설
                        //1. settingStyle에 "h1"이라는 인자를 넣어서 실행한다.
                        //2. 실행될 함수에 한번더 인자를 주게되면 return에서 실행되는 함수에 인자를 준다.

                        document.getElementById("testDiv").append(title);//스타일을 적용시킨 h1 태그를 추가
                
                ● 위의 다중 함수 실행에 대한 테스트
                        예시)
                            const add1 = (a = 0, b = 0) => {
                                console.log(`add 1 : ${a} + ${b} = ${a+b}`);
                                return add2 = (c = 0, d = 0) =>{
                                    console.log(`add 2 : ${c} + ${d} = ${c+d}`);
                                    return add3 = (e, f = 0) =>{
                                        console.log(`add 3 : ${e} + ${f} = ${e+f}`);
                                    }
                                }
                            };

                            add1(1,1)(2,2)(3,3);
                            //출력 목록
                            //add 1 : 1 + 1 = 2
                            //add 2 : 2 + 2 = 4
                            //add 3 : 3 + 3 = 6
            </pre>
        </span>
        <span>▶ 백틱에 의한 함수 호출 방법
            <pre>
                ● 기본편
                    예시)
                        위의 add1를 실행할때
                        add1`1`,(2,2)(3,3);로 실행해도 된다.
                        대신 이 경우에는 1이 숫자가 아닌 문자열이니 이 부분은 조심해야 한다.
                        //출력 목록
                        //add 1 : 1 + 0 = 10
                        //add 2 : 2 + 2 = 4
                        //add 3 : 3 + 3 = 6

                ● 응용편
                    예시)
                        const test = {
                            first : "first",
                            second : "second"
                        };

                        function amazing(strings, var1, var2){
                            //인자를 꼬아서 strings를 맨뒤로 보내보면 인자를 어떻게 받는지 알수있다.
                            console.log(strings);
                            console.log(var1);
                            console.log(var2);
                            return `${strings[0]}${var1}${strings[1]}${var2}${strings[2]}`;
                        }

                        console.log(amazing`시작-${test.first}-중간-${test.second}-끝`);//출력 : 시작-first-중간-second-끝

                        //해설
                        //백틱을 사용해서 실행하게 되는 함수는 첫번째 인자에
                        //백틱에서 사용되었던 ${}를 제외한 문자열들이 배열로 저장되게 된다.
                        //첫번째 인자 이후의 인자들은 ${}로 사용한 인자들이 차례대로 저장된다. 
            </pre>
        </span>
    </section>
    <span>▶ 문자열 메소드
        <pre>
            ● include("찾을 문자열") : 해당 문자열이 존재하는가 검색
            ● "문자열".repeat(n) : n번만큼 문자열을 반복
            ● "문자열".startsWith("찾을 문자열") : 해당 문자열로 시작되는지 확인
            ● "문자열".endsWith("찾을 문자열") : 해당 문자열로 종료되는지 확인
        </pre>
    </span>
</section>

<br>

<section id="array">
    <span>
        <bold>배열 메소드</bold>
    </span>
    <span>▶ 배열 메소드
        <pre>
            ● Array.of(...) : 넣은 데이터들을 배열로 만들어준다.
                예시)
                    const testArray = Array.of(3, true, "what");

            ● Array.from(...) : 넣은 데이터들을 배열로 만들어준다.
                예시)
                    //만약 buttonTest라는 class명을 가진 버튼들이 여러개 있다고 헀을 때

                    const buttonArray = document.getElementsByClassName("buttonTest");
                    Array.from(buttonArray).forEach(button => button.addEventListener("click", () => console.log("test")));

                    //이런식으로 이벤트를 추가해주려고 한다면 에러가 발생한다.
                    //왜냐하면 forEach는 Array 객체의 메소드인데 코드에 있는 buttonArray는 배열이 아니기 때문이다.
                    //실제로는 HTML Collection라는 Array-Like Object다.
                    //그렇기 때문에 코드에 있는 buttonArray에 ForEach를 사용하고 싶다면
                    //Array.from(buttonArray)를 해줘서 배열로 만들어준 다음에 ForEach를 사용하면 된다.

            ● Array.find(조건) : 배열에 있는 데이터들에 대하여 조건에 맞는 것들만 데이터 중 첫번째 요소의 값을 찾아준다.
                예시)
                    const testArray = ["testA", "testB", "testC", "textD", "textE"];
                    const findStartTextIsTestArray = testArray.find(element => element.startsWith("test"));
                    console.log(findStartTextIsTestArray);  //출력 : testA

            ● Array.findIndex(조건) : 배열에 있는 데이터들에 대하여 조건에 맞는 것들만 데이터 중 첫번째 요소의 인덱스를 찾아준다.
                예시)
                    const testArray = ["testA", "testB", "testC", "textD", "textE"];
                    const findStartTextIsTestArray = testArray.findIndex(element => element.startsWith("test"));
                    console.log(findStartTextIsTestArray);  //출력 : 0

            ● Array.fill(문자열, x, y) : 배열의 인덱스 중 x에서 y까지 설정한 문자열로 교체, y 생략시 x에서 마지막 인덱스까지 전부 교체
                예시) 
                    const testArray = ["testA", "testB", "testC", "textD", "textE"];    
                    testArray.fill("###", 3);
                    console.log(testArray); //출력 : ["testA", "testB", "testC", "###", "###"]
        </pre>
    </span>

    <br>

    <section id="destructuring">
        <span>
            <bold>비구조화</bold>
        </span>
        <span>▶ 비구조화 (destructuring)
            <pre>
                ● 정의 : 객체나 배열 등의 요소 안에 있는 변수들을 바깥으로 끄집어 내서 사용할 수 있도록 하는 것
            </pre>
        </span>
        <span>▶ 객체의 비구조화
            <pre>
                ● 객체의 내부 요소에 접근하는 기본적인 방식
                    예시)
                        //다음과 같이 학생에 대한 정보가 있다고 했을 때

                        const student = {
                            name : "who",
                            classInfo : {
                                gradeNo : 3,
                                classNo : 10
                            },
                            score : {
                                math : 97,
                                sience : 87,
                                english : 65
                            }
                        };
                    
                        //해당 학생의 수학 점수를 보기 위한 방법
                        console.log("score :", student.score.math);
                        //보통은 이렇게 하지만 만약 math라는 항목이 없다면 undefined가 출력된다.

                ● 객체의 내부 요소에 접근하는 새로운 방식
                    예시)
                        //위의 코드에 있는 student 객체에서 이름, 학년, 반, 수학 점수를 찾을 때 밑의 코드처럼 선언한다.
                        const {
                            name,
                            classInfo : {gradeNo, classNo},
                            score : {math}
                        } = student;

                        //방금 작성된 코드는 다음의 코드와 내용이 같다.
                        //const name = student.name;
                        //const gradeNo = student.classInfo.gradeNo;
                        //const classNo = student.classInfo.classNo;
                        //const math = student.score.math;

                        //실제로 math를 찍어보면 결과가 나온다.
                        console.log(math);  //출력 : 97
                        //만약, 수학 시험날에 일이 있어서 시험이 못치는 경우도 있으니 그럴 때는 default value를 주면 된다.

                        //혹시나 var나 let으로 선언해서 저 코드에서 math = 100;을 해도 실제 student의 값이 바뀌지는 않는다.

                ● 이름 변경 (Renaming)
                        예시)
                            //아까 작성하던 코드 중에서 수학 점수를 찾을 때 math라는 이름으로 사용되었다.
                            //하지만 이렇게 짧은 코드가 아니라 무척 길고 어려운 코드를 짜다보면
                            //math라는게 해당 과목에 대한 점수를 얘기하는 건지 담당 선생님을 얘기하는 건지 헷갈릴 수가 있다.
                            //그래서 객체의 비구조화를 진행할 때 Renaming을 진행한다.

                            //아까 쓰던 코드는 다음과 같다.
                            const {
                                name,
                                classInfo : {gradeNo, classNo},
                                score : {math}
                            } = student;
                            
                            //여기서 math를 mathScore로 해주고, 혹시 모르니 점수를 기본 값으로 0을 주려고 한다면 다음과 같이 작성하면 된다.
                            const {
                                name,
                                classInfo : {gradeNo, classNo},
                                score : {math : mathScore = 0}
                            } = student;
            </pre>
        </span>
        <span>▶ 배열의 비구조화 : 가져온 정보를 조작할 일이 없을 때 쓰는 것이 좋다.
            <pre>
                ● 배열의 내부 요소에 접근하는 기본적인 방식
                    예시)
                        const test = ["testA", "testB", "testC"];

                        console.log(test[0]);//출력 : testA

                ● 배열의 내부 요소에 접근하는 새로운 방식
                    예시 1)
                        //위의 코드에 있는 test 배열을 사용한다고 했을 때
                        
                        const [test0, test1, test2] = test; //각 인덱스에 객체처럼 이름을 준다고 생가하면 된다.

                        console.log(test0); //출력 : testA

                    예시 2)
                        //객체를 반환하는 함수에도 사용할 수 있다.
                        const test = () => ["testA", "testB", "testC"];
                        const [test0, test1, test2] = test();
                        console.log(test0); //출력 : testA

                ● Variable Swapping (값 교환)
                    ○ 일반적인 값 교환
                        예시)
                            var a=1, b=2 ,temp;
                            console.log("a =>",a,", b =>",b); //출력 : a => 1 , b => 2
                            temp=a;
                            a=b;
                            b=temp;
                            console.log("a =>",a,", b =>",b); //출력 : a => 2 , b => 1
                    ○ 배열의 비구조화를 통한값 교환
                        예시)
                            var a=1, b=2 ,temp;
                            console.log("a =>",a,", b =>",b); //출력 : a => 1 , b => 2
                            [a, b] = [b, a];
                            console.log("a =>",a,", b =>",b); //출력 : a => 2 , b => 1

                ● Variable Omitting (값 생략)
                    const test = ["testA", "testB", "testC"];

                    //위의 test 배열에서 "testC"만 가져오고 싶을 때
                    const [ , , omittingTest] = test;
                    console.log(omittingTest);  //출력 : testC
            </pre>
        </span>
        <span>▶ 함수의 비구조화
            <pre>
                ● 함수의 내부 요소에 접근하는 기본적인 방식
                    예시)
                        //인자가 너무 많아지면 좋지 않다.
                        function test (a, b, c, d, e){
                            ...;
                        }
                ● 함수의 내부 요소에 접근하는 새로운 방식
                    예시)
                        //인자가 많으면 아예 인자를 객체로 받는다.
                        function test({name, classInfo, score}){
                            console.log(score.math);
                        }

                        //함수 호출
                        test({
                            name : "who",
                            classInfo : {
                                gradeNo : 3,
                                classNo : 10
                            },
                            score : {
                                math : 97,
                                sience : 87,
                                english : 65
                            }
                        });

                        //출력 : 97

                        ★ 문제점 : 만약에 score의 math를 부르는데 그 값이 없으면 default value를 설정해줘야 하는데 그 방법을 전혀 알 수가 업었다.
                            ▷ 시도 1 : score={math:0} => 실패
                            ▷ 시도 2 : score : {math:0} => 실패
                            ▷ 시도 3 : score : {math=0} => 실패
            </pre>
        </span>
        <span>▶ 변수명 단축
            <pre>
                //만약 다음과 같은 함수가 있다고 가정해보자.
                const test = () => console.log("execute function, function name : test");

                //그 다음에는 obj라는 객체가 있고 해당 객체에는 what과 test라는 항목이 있다고 했을 때
                //what에는 "whatever text"를 test에는 아까 선언한 test라는 함수를 저장하고자 한다면
                //일반적으로는 다음과 같이 선언한다.

                const obj = {
                    whatever : "whatever text",
                    test : test
                };
                obj.test(); //출력 : execute function, function name : test

                //하지만 발전해버린 JavaScript는 똑똑해졌기 때문에
                //만약 객체에서 해당 항목에 값을 생략해버리면
                //해당 항목과 같은 이름을 가진 변수를 값으로 저장한다.

                const obj = {
                    whatever : "whatever text",
                    test
                };
                obj.test(); //출력 : execute function, function name : test
            </pre>
        </span>
    <!-- 테스트용 -->
    <div class="" id="testDiv">테스트 영역</div>
</body>

</html>