<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES Series</title>
    <link rel="stylesheet" href="../css/index.css" />
</head>

<body>
    <section id="variable">
        <span>
            <bold>변수</bold>
        </span>
        <span>▶ let & const
            <pre>
                ● let : 기존의 var같은 자료형, 변수 재선언 불가, 변수 재할당 가능
                    예시 - var의 경우)
                        var str = "test";
                        var str = "example";//에러 없음
                    예시 - let의 경우)
                        let str = "test";
                        let str = "example";//에러 발생
                ● const : 변수 재선언 불가, 변수 재할당 특정 상황에 한해서 가능
                    예시 - 기본적인 변수의 경우)
                        const str = "test";
                        const str = "example";//에러 없음
                        str = "example";//에러 없음
                    예시 - 객체의 경우)
                        const str = {
                            text : "test"
                        };
                        str.name = "example";//에러 없음

                ※ 기본적인 변수는 왠만하면 const를 쓰고, 재할당할 변수만 let을 하는게 좋다.
            </pre>
        </span>
        <span>▶ Dead Zone
            <pre>
                ● 호이스팅 (Hoisting) : 자바스크립트가 프로그램을 실행하기 전에
                                       var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성
                ● var때문에 생겨나는 호이스팅의 문제점
                    예시) 만약 아래와 같은 코드가 있다고 했을 때
                          console.log(str);
                          var str = "test";
                        
                          자바스크립트는 내부에서 다음과 같이 변환한다.
                          var str;
                          console.log(str);//출력 : undefined
                          str = "test";

                          위의 코드에서는 원래 undefined가 나오면 안된다.
                          원래는 에러가 발생해야 되지만 호이스팅에 의해서 undefined가 발생한다.
                ● let과 const를 써야 하는 이유 :
                    let과 const를 쓰면 위의 코드를 똑같이 사용한다 가정했을 떄
                    이 경우에는 str은 선언하지 않은 변수라고 에러가 발생하게 된다.
            </pre>
        </span>
        <span>▶ Block Scope
            <pre>
                ● let과 const의 경우에는 블록 내부에서만 사용이 가능하다.
                    예시)
                        if(true){ let test = "test";}
                        console.log(test);  //에러 발생
                ● var의 경우에는 블록 내부/외부 상관없이 간섭이 가능하다.
                    예시)
                        if(true){ var test = "test";}
                        console.log(test);  //출력 : test;
                
                ※ 함수의 경우에는 var도 내부/외부 구분이 가능은 하지만 코딩의 실수로 간섭이 발생할수 있기 때문에
                   왠만하면 let과 const를 사용하는 것이 낫다.
            </pre>
        </span>
    </section>

    <br>

    <section id="function">
        <span>
            <bold>함수</bold>
        </span>
        <span>▶ Array.map()
            <pre>
                ● map : 각 요소를 읽는 역할을 한다.
                        인자로 넣은 함수에 각 요소들을 넣으면서 반복한다.
                        반복하면서 실행된 값들은 다시 배열에 모여서 반환된다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        function example(item){return item + "TEST";}
                        const test = somethings.map(example);//test라는 배열에 실행 값들이 저장된다.
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
            </pre>
        </span>
        <span>▶ Arrow Function
            <pre>
                ● 위와 같은 코드를 사용한다고 했을 때 ES6에 추가된 Arrow Function을 사용하면 아래처럼 바뀐다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(item => {
                            return item + "TEST";
                        });
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
                
                ● 하지만 방금의 코드는 기본적인 코드였고, 실제로는 좀 더 간단하게 줄일수 있다. (implicit return : 암시적 리턴)
                  암시적 리턴의 경우에는 {}가 없어야 실행된다. {}를 할 경우에는 undefined를 반환하기 때문에 return을 명시해줘야 한다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(item => item + "TEST");
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]

                ● 또다른 예시 (연산자가 없는 숫자나 문자열로 단순 초기화시 사용, map의 경우)
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(() => item + "TEST");
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
            </pre>
        </span>
        <span>▶ Arrow Function에서의 this
            <pre>
                ● this를 사용해야 하는 상황에서는 Arrow Function을 사용하면 안 된다.
                    예시)
                        addEventListener의 매개 변수 중 함수명을 선언하는 곳에
                        ()=>{console.log(this);}라고 작성한다면
                        현재 이 리스너가 버튼에 적용된다고 가정했을 때
                        출력은 button 태그가 아니라 window가 찍힌다.

                ● 주의점
                    리스너에서 사용할 때 ()=>{console.log(this);}라고 작성하면
                    this는 window를 가리키지만
                    function ()=>{console.log(this);}로 작성하면
                    그 때는 button 태그를 가리킨다.
                    즉, function 예약어의 유무에 따라 this가 가리키는 위치가 달라진다.

                ● 객체에 대한 Arrow Function
                    예시 1)
                        const test = {
                            name : "who",
                            age : 25,
                            addYear : () => {
                                this.age++;
                            }
                        };
                        test.addYear();
                        console.log(test.age);//출력 : 25, 이유 : this가 window를 가리킨다.
                    예시 2)
                    const test = {
                        name : "who",
                        age : 25,
                        addYear(){
                            this.age++;
                        }
                    };
                    test.addYear();
                    console.log(test.age);//출력 : 25, 이유 : this가 객체를 가리킨다.

                    ※ 즉, 객체의 메소드 내부에서 사용하는 this가
                       객체 자신을 가리키게 하고 싶다면 Arrow Function을 사용하면 안된다.
            </pre>
        </span>
        <span>▶ Arrow Function의 실제 사용법
            <pre>
                ● 이메일 찾기 (find : 첫번째 값 반환)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const foundMail = email.find(item => item.includes("@gmail.com"));
                    console.log(foundMail); //출력 : test2@gmail.com

                ● 이메일 필터 (filter : 배열 반환)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const foundMail = email.filter(item => item.includes(".com"));
                    console.log(foundMail); //출력 : ["test1@naver.com", "test2@gmail.com"]

                ● 유저명 저장 (forEach : 반복문)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    email.forEach(
                        test => { console.log(test.split("@")[0]); }
                    );
                    
                ● 유저명 저장 (map : forEach 형식으로 반환된 데이터들을 배열에 저장)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const userNames = email.map(test=>test.split("@")[0]);

                    ※ email.map((test, index) => {name : test.split("@")[0], point : index});처럼 객체로도 반환가능하다.
            </pre>
        </span>
        <span>▶ Default Value (기본 값)
            <pre>
                ● 기본적인 함수의 사용 방법
                    예시)
                        function basicFunction(text){ console.log(text);}
                        basicFunction("test message");//출력 : text message

                ● 값이 없을 경우의 임시 값을 추가하는 방법
                    예시)
                        function noneValueTestFunction(text){ console.log((text || "none value"));}
                        noneValueTestFunction();//출력 : none value

                ● Default Value를 사용하는 방법
                    예시)
                        function defaultValueFunction(text = "default value"){ console.log(text);}
                        defaultValueFunction();//출력 : default value

                ● Default Value와 Arrow Function을 함께 사용하는 방법
                    예시)
                        const defualValueAndArrowFunction = (text = "default value & arrow function") => console.log(text);
                        defualValueAndArrowFunction();//출력 : default value & arrow function
                    
                ※ Default Value는 단순한 텍스트뿐만 아니라 숫자나 변수나 객체 등 뭐든 올수 있다.
            </pre>
        </span>
    </section>

    <br>

    <section id="string">
        <span>
            <bold>문자열</bold>
        </span>
        <span>▶ Template Literal
            <pre>
                ● 기본적인 문자열 합치기
                    const test = (text = "test") => "execute " + text +" !!!";
                    console.log(test());    //출력 : execute test !!!
                    //1. 번거롭다.
                    //2. 헷갈릴 위험도 크다.

                ● 백틱과 함께 쓰기 - 기본편 (` : 물결표랑 같이 있는 기호)
                    const test = (text = "test") => `execute ${text} !!!`;
                    console.log(test());    //출력 : execute test !!!

                ● 백틱과 함께 쓰기 - 응용편 (함수 사용)
                    const add = (a, b) => a + b;
                    const test = (text = "test") => `execute ${add(1, 6)} !!!`;
                    console.log(test());    //출력 : execute 7 !!!
            </pre>
        </span>
        <span>▶ HTML 태그 & Template Literal
            <pre>
                ● 사용법
                    const testDiv = document.getElementById("testDiv");
                    const span = `&lt;span>This is HTML Tag + Template Literal !!!&lt;/span>`;
                    testDiv.innerHTML = span;

                ● 응용법
                    const testArray = ["a", "b", "c"];
                    const testDiv = document.getElementById("testDiv");
                    const list =
                    `&lt;ul>${testArray.map(test => `&lt;li>${test} ★&lt;/li>`).join("")}&lt;/ul>`;
                    testDiv.innerHTML = list;
                
                ※ 백틱(`)은 엔터를 입력하면 엔터도 적용을 시켜준다. ===> &lt;br>을 사용할 필요가 없어진다.
            </pre>
        </span>
        <span>▶ Style을 적용시킨 노드 만들기
            <pre>
                ● css를 적용시킨 태그를 반환하는 방법
                    예시)
                        const settingStyle = newElement =>{
                            const newEle = document.createElement(newElement);//신규 태그 생성

                            return args = (text ="test text", styleArray) => {
                                const settingStyleOptions = styleArray;  //css로 적용할 값들을 불러와서 저장
                                newEle.style = settingStyleOptions;   //태그에 css 적용
                                newEle.innerHTML = text;
                                return newEle;  //태그 반환
                            };
                        };

                        const title = settingStyle("h1")("hmm",`
                            color : white;
                            background-color : blue;
                            font-weight : bold;
                        `);
                        //해설
                        //1. settingStyle에 "h1"이라는 인자를 넣어서 실행한다.
                        //2. 실행될 함수에 한번더 인자를 주게되면 return에서 실행되는 함수에 인자를 준다.

                        document.getElementById("testDiv").append(title);//스타일을 적용시킨 h1 태그를 추가
                
                ● 위의 다중 함수 실행에 대한 테스트
                        예시)
                            const add1 = (a = 0, b = 0) => {
                                console.log(`add 1 : ${a} + ${b} = ${a+b}`);
                                return add2 = (c = 0, d = 0) =>{
                                    console.log(`add 2 : ${c} + ${d} = ${c+d}`);
                                    return add3 = (e, f = 0) =>{
                                        console.log(`add 3 : ${e} + ${f} = ${e+f}`);
                                    }
                                }
                            };

                            add1(1,1)(2,2)(3,3);
                            //출력 목록
                            //add 1 : 1 + 1 = 2
                            //add 2 : 2 + 2 = 4
                            //add 3 : 3 + 3 = 6
            </pre>
        </span>
        <span>▶ 백틱에 의한 함수 호출 방법
            <pre>
                ● 기본편
                    예시)
                        위의 add1를 실행할때
                        add1`1`,(2,2)(3,3);로 실행해도 된다.
                        대신 이 경우에는 1이 숫자가 아닌 문자열이니 이 부분은 조심해야 한다.
                        //출력 목록
                        //add 1 : 1 + 0 = 10
                        //add 2 : 2 + 2 = 4
                        //add 3 : 3 + 3 = 6

                ● 응용편
                    예시)
                        const test = {
                            first : "first",
                            second : "second"
                        };

                        function amazing(strings, var1, var2){
                            //인자를 꼬아서 strings를 맨뒤로 보내보면 인자를 어떻게 받는지 알수있다.
                            console.log(strings);
                            console.log(var1);
                            console.log(var2);
                            return `${strings[0]}${var1}${strings[1]}${var2}${strings[2]}`;
                        }

                        console.log(amazing`시작-${test.first}-중간-${test.second}-끝`);//출력 : 시작-first-중간-second-끝

                        //해설
                        //백틱을 사용해서 실행하게 되는 함수는 첫번째 인자에
                        //백틱에서 사용되었던 ${}를 제외한 문자열들이 배열로 저장되게 된다.
                        //첫번째 인자 이후의 인자들은 ${}로 사용한 인자들이 차례대로 저장된다. 
            </pre>
        </span>
    </section>
    <span>▶ 문자열 메소드
        <pre>
            ● include("찾을 문자열") : 해당 문자열이 존재하는가 검색
            ● "문자열".repeat(n) : n번만큼 문자열을 반복
            ● "문자열".startsWith("찾을 문자열") : 해당 문자열로 시작되는지 확인
            ● "문자열".endsWith("찾을 문자열") : 해당 문자열로 종료되는지 확인
        </pre>
    </span>
</section>

<br>

<section id="array">
    <span>
        <bold>배열 메소드</bold>
    </span>
    <span>▶ 배열 메소드
        <pre>
            ● Array.of(...) : 넣은 데이터들을 배열로 만들어준다.
                예시)
                    const testArray = Array.of(3, true, "what");

            ● Array.from(...) : 넣은 데이터들을 배열로 만들어준다.
                예시)
                    //만약 buttonTest라는 class명을 가진 버튼들이 여러개 있다고 헀을 때

                    const buttonArray = document.getElementsByClassName("buttonTest");
                    Array.from(buttonArray).forEach(button => button.addEventListener("click", () => console.log("test")));

                    //이런식으로 이벤트를 추가해주려고 한다면 에러가 발생한다.
                    //왜냐하면 forEach는 Array 객체의 메소드인데 코드에 있는 buttonArray는 배열이 아니기 때문이다.
                    //실제로는 HTML Collection라는 Array-Like Object다.
                    //그렇기 때문에 코드에 있는 buttonArray에 ForEach를 사용하고 싶다면
                    //Array.from(buttonArray)를 해줘서 배열로 만들어준 다음에 ForEach를 사용하면 된다.

            ● Array.find(조건) : 배열에 있는 데이터들에 대하여 조건에 맞는 것들만 데이터 중 첫번째 요소의 값을 찾아준다.
                예시)
                    const testArray = ["testA", "testB", "testC", "textD", "textE"];
                    const findStartTextIsTestArray = testArray.find(element => element.startsWith("test"));
                    console.log(findStartTextIsTestArray);  //출력 : testA

            ● Array.findIndex(조건) : 배열에 있는 데이터들에 대하여 조건에 맞는 것들만 데이터 중 첫번째 요소의 인덱스를 찾아준다.
                예시)
                    const testArray = ["testA", "testB", "testC", "textD", "textE"];
                    const findStartTextIsTestArray = testArray.findIndex(element => element.startsWith("test"));
                    console.log(findStartTextIsTestArray);  //출력 : 0

            ● Array.fill(문자열, x, y) : 배열의 인덱스 중 x에서 y까지 설정한 문자열로 교체, y 생략시 x에서 마지막 인덱스까지 전부 교체
                예시) 
                    const testArray = ["testA", "testB", "testC", "textD", "textE"];    
                    testArray.fill("###", 3);
                    console.log(testArray); //출력 : ["testA", "testB", "testC", "###", "###"]
        </pre>
    </span>

    <br>

    <section id="destructuring">
        <span>
            <bold>비구조화</bold>
        </span>
        <span>▶ 비구조화 (destructuring)
            <pre>
                ● 정의 : 객체나 배열 등의 요소 안에 있는 변수들을 바깥으로 끄집어 내서 사용할 수 있도록 하는 것
            </pre>
        </span>
        <span>▶ 객체의 비구조화
            <pre>
                ● 객체의 내부 요소에 접근하는 기본적인 방식
                    예시)
                        //다음과 같이 학생에 대한 정보가 있다고 했을 때

                        const student = {
                            name : "who",
                            classInfo : {
                                gradeNo : 3,
                                classNo : 10
                            },
                            score : {
                                math : 97,
                                sience : 87,
                                english : 65
                            }
                        };
                    
                        //해당 학생의 수학 점수를 보기 위한 방법
                        console.log("score :", student.score.math);
                        //보통은 이렇게 하지만 만약 math라는 항목이 없다면 undefined가 출력된다.

                ● 객체의 내부 요소에 접근하는 새로운 방식
                    예시)
                        //위의 코드에 있는 student 객체에서 이름, 학년, 반, 수학 점수를 찾을 때 밑의 코드처럼 선언한다.
                        const {
                            name,
                            classInfo : {gradeNo, classNo},
                            score : {math}
                        } = student;

                        //방금 작성된 코드는 다음의 코드와 내용이 같다.
                        //const name = student.name;
                        //const gradeNo = student.classInfo.gradeNo;
                        //const classNo = student.classInfo.classNo;
                        //const math = student.score.math;

                        //실제로 math를 찍어보면 결과가 나온다.
                        console.log(math);  //출력 : 97
                        //만약, 수학 시험날에 일이 있어서 시험이 못치는 경우도 있으니 그럴 때는 default value를 주면 된다.

                        //혹시나 var나 let으로 선언해서 저 코드에서 math = 100;을 해도 실제 student의 값이 바뀌지는 않는다.

                ● 이름 변경 (Renaming)
                        예시)
                            //아까 작성하던 코드 중에서 수학 점수를 찾을 때 math라는 이름으로 사용되었다.
                            //하지만 이렇게 짧은 코드가 아니라 무척 길고 어려운 코드를 짜다보면
                            //math라는게 해당 과목에 대한 점수를 얘기하는 건지 담당 선생님을 얘기하는 건지 헷갈릴 수가 있다.
                            //그래서 객체의 비구조화를 진행할 때 Renaming을 진행한다.

                            //아까 쓰던 코드는 다음과 같다.
                            const {
                                name,
                                classInfo : {gradeNo, classNo},
                                score : {math}
                            } = student;
                            
                            //여기서 math를 mathScore로 해주고, 혹시 모르니 점수를 기본 값으로 0을 주려고 한다면 다음과 같이 작성하면 된다.
                            const {
                                name,
                                classInfo : {gradeNo, classNo},
                                score : {math : mathScore = 0}
                            } = student;
            </pre>
        </span>
        <span>▶ 배열의 비구조화 : 가져온 정보를 조작할 일이 없을 때 쓰는 것이 좋다.
            <pre>
                ● 배열의 내부 요소에 접근하는 기본적인 방식
                    예시)
                        const test = ["testA", "testB", "testC"];

                        console.log(test[0]);//출력 : testA

                ● 배열의 내부 요소에 접근하는 새로운 방식
                    예시 1)
                        //위의 코드에 있는 test 배열을 사용한다고 했을 때
                        
                        const [test0, test1, test2] = test; //각 인덱스에 객체처럼 이름을 준다고 생가하면 된다.

                        console.log(test0); //출력 : testA

                    예시 2)
                        //객체를 반환하는 함수에도 사용할 수 있다.
                        const test = () => ["testA", "testB", "testC"];
                        const [test0, test1, test2] = test();
                        console.log(test0); //출력 : testA

                ● Variable Swapping (값 교환)
                    ○ 일반적인 값 교환
                        예시)
                            var a=1, b=2 ,temp;
                            console.log("a =>",a,", b =>",b); //출력 : a => 1 , b => 2
                            temp=a;
                            a=b;
                            b=temp;
                            console.log("a =>",a,", b =>",b); //출력 : a => 2 , b => 1
                    ○ 배열의 비구조화를 통한값 교환
                        예시)
                            var a=1, b=2 ,temp;
                            console.log("a =>",a,", b =>",b); //출력 : a => 1 , b => 2
                            [a, b] = [b, a];
                            console.log("a =>",a,", b =>",b); //출력 : a => 2 , b => 1

                ● Variable Omitting (값 생략)
                    const test = ["testA", "testB", "testC"];

                    //위의 test 배열에서 "testC"만 가져오고 싶을 때
                    const [ , , omittingTest] = test;
                    console.log(omittingTest);  //출력 : testC
            </pre>
        </span>
        <span>▶ 함수의 비구조화
            <pre>
                ● 함수의 내부 요소에 접근하는 기본적인 방식
                    예시)
                        //인자가 너무 많아지면 좋지 않다.
                        function test (a, b, c, d, e){
                            ...;
                        }
                ● 함수의 내부 요소에 접근하는 새로운 방식
                    예시)
                        //인자가 많으면 아예 인자를 객체로 받는다.
                        function test({name, classInfo, score}){
                            console.log(score.math);
                        }

                        //함수 호출
                        test({
                            name : "who",
                            classInfo : {
                                gradeNo : 3,
                                classNo : 10
                            },
                            score : {
                                math : 97,
                                sience : 87,
                                english : 65
                            }
                        });

                        //출력 : 97

                        ★ 문제점 : 만약에 score의 math를 부르는데 그 값이 없으면 default value를 설정해줘야 하는데 그 방법을 전혀 알 수가 업었다.
                            ▷ 시도 1 : score={math:0} => 실패
                            ▷ 시도 2 : score : {math:0} => 실패
                            ▷ 시도 3 : score : {math=0} => 실패
            </pre>
        </span>
        <span>▶ 변수명 단축
            <pre>
                //만약 다음과 같은 함수가 있다고 가정해보자.
                const test = () => console.log("execute function, function name : test");

                //그 다음에는 obj라는 객체가 있고 해당 객체에는 what과 test라는 항목이 있다고 했을 때
                //what에는 "whatever text"를 test에는 아까 선언한 test라는 함수를 저장하고자 한다면
                //일반적으로는 다음과 같이 선언한다.

                const obj = {
                    whatever : "whatever text",
                    test : test
                };
                obj.test(); //출력 : execute function, function name : test

                //하지만 발전해버린 JavaScript는 똑똑해졌기 때문에
                //만약 객체에서 해당 항목에 값을 생략해버리면
                //해당 항목과 같은 이름을 가진 변수를 값으로 저장한다.

                const obj = {
                    whatever : "whatever text",
                    test
                };
                obj.test(); //출력 : execute function, function name : test
            </pre>
        </span>
    </section>
    

    <br>

    <section id="restAndSpread">
        
        <span>
            <bold>Rest & Spread</bold>
        </span>
        <span>▶ Rest Parameters (남는 값들)
            <pre>
                ● 함수의 파라미터 중에서 필요한 차례의 매개변수까지 선언해준 후에 "...변수명"를 해주면 그 이름의 배열이 된다.
                    예시 1 - 일반적인 함수 호출 방법 )
                        function test(a,b, ...temp){
                            console.log("두번째 인자의 값 =>", b);
                            console.log("나머지 값들 =>", temp);
                        }

                        test("testA", "testB", "testC", "testD", "testE");

                        //출력 1 : 두번째 인자의 값 => testB
                        //출력 2 : 나머지 값들 => ["testC", "testD", "testE"]

                        ※ 보통은 rest라는 이름으로 많이 쓴다.
                        ※ 만약 5개를 받았는데 3번째 인자를 쓰고 싶다면 1번째에서 3번째까지의 매개변수까지는 선언을 해주고 "...변수명"을 해줘야 한다.

                    예시 2 - 객체를 매개변수로 하는 함수 호출 방법 )
                        function test({b, ...temp}){
                            console.log("b의 값 =>", b);
                            console.log("나머지 값들 =>", temp);
                        }

                        const obj = {
                            x1 : 1,
                            b : 3,
                            x2 : 2
                        };

                        test(obj);

                        //출력 1 : b의 값 => 3
                        //출력 2 : {x1: 1, x2: 2}

                        ※ 객체를 매개변수로 줄 때는 같은 이름의 항목이 있으면 바로 그 이름을 선언해서 순서상관없이 그 값을 가져올 수 있다.
            </pre>
        </span>
        <span>▶ Spread : 변수를 가져와서 풀어준 다음 전개하는 것
            <pre>
                ● 일반적인 배열 출력
                    const test = ["a", "b", "c"];
                    console.log(test);  //출력 : ["a", "b", "c"], 배열 자체가 출력된다.

                ● Spread를 통한 배열 출력
                    const test = ["a", "b", "c"];
                    console.log(...test);  //출력 : a b c, 배열의 값들이 출력된다.

                ● Spread를 통한 배열 합치기
                    const test1 = ["a", "b", "c"];
                    const test2 = [1, 2, 3];

                    const testMerge = [...test1, ...test2]; //[]와 쉼표 사용
                    console.log(testMerge);  //출력 : ["a", "b", "c", 1, 2, 3]


                ● Spread를 통한 객체 합치기
                    const test1 = {name : "test1", a : 1};
                    const test2 = {name : "test2", b : 2};

                    const testMerge = {...test1, ...test2}; //[]와 쉼표 사용
                    console.log(testMerge);  //출력 : {name: "test2", a: 1, b: 2}

                    ※ 만약에 같은 이름이 있다면 나중에 온 값으로 덮어씌워지게 된다.

                ● Spread를 통한 객체의 항목 추가
                    ○ 기본 문법 : ...(condition && object), condition : 조건, object : 추가할 객체

                    예시)
                        const testText = prompt("whatever text");

                        const testObject = {
                            name : "testObject",
                            ...(testText!=="" && {testText})
                        };

                    //{}를 붙이는 것은 Spread를 하기 위해 ...를 하려면 배열이나 객체여야 한다.

                    //테스트 1 : testText가 ""인 경우
                    console.log(testObject); //출력 : {name: "testObject"}

                    //테스트 2 : testText가 "testText"인 경우
                    console.log(testObject); //출력 : {name: "testObject", testText: "testText"}

                    //해설
                    //1. 기본 문법에 의해서 && 앞에 오는 값이 true면 해당 객체에서는 && 뒤의 객체를 항목으로 추가한다.
                    //2. 원래는 ...(testText!=="" && testText)가 맞겠지만 testText는 객체가 아닌 문자열이니 {}를 붙여준다.
                    //3. ...(testText!=="" && {testText})를 원래대로 돌려보면 아래의 코드처럼 나온다.
                    //4. ...(testText!=="" && {testText : testText}), 변수명 단축의 원리가 적용되어 있다.
                    //5. 결론은 JavaScript가 똑똑해져버린 ES6부터 가능한 놀라운 기능이다. (익스플로러 안 됨)
            </pre>
        </span>
        <span>▶ Rest & Spread : 변수를 가져와서 풀어준 다음 전개하는 것
            <pre>
                ● 객체에 있는 항목을 깔끔하게 없애기
                    const user = {
                        name: "who",
                        age: 24,
                        password: 12345,
                        };
                        
                    user["password"] = null;
                    
                    console.log(user);  //출력 : {name: "who", age: 24, password: null}, 항목이 남아있다.
                    
                    const killPassword = ({ password, ...rest }) => rest;
                    
                    const cleanUser = killPassword(user);
                    
                    console.log(cleanUser); //출력 : {name: "who", age: 24}, 항목이 사라졌다.
            </pre>
        </span>
    </section>

    <br>

    <section id="forOfLoop">
        <span>
            <bold>For of Loop</bold>
        </span>
        <span>▶ 발전된 for문 (for-of문)
            <pre>
                const test = ["testA", "testB", "testC"];

                for(const t of test){
                    console.log(t);
                }

                //결과
                //출력 1 : testA
                //출력 2 : testB
                //출력 3 : testC

                //1. var or let or const로 자료형을 선언한다.
                //2. 배열에 접근할 수 있는 변수의 이름을 정한다.
                //3. of를 작성한 다음에 접근할 배열의 이름을 작성한다.
            </pre>
        </span>
        <span>▶ forEach문
            <pre>
                ● 기본적인 forEach문 (배열명.forEach(...))
                    const test = ["testA", "testB", "testC"];

                    test.forEach((element, index, nowArray)=>{
                        console.log("현재 요소 :", element, ", 현재 인덱스 :", index, ", 현재 배열 :", test);
                    });

                    //결과
                    //출력 1 : 현재 요소 : testA , 현재 인덱스 : 0 , 현재 배열 : (3) ["testA", "testB", "testC"]
                    //출력 2 : 현재 요소 : testB , 현재 인덱스 : 1 , 현재 배열 : (3) ["testA", "testB", "testC"]
                    //출력 3 : 현재 요소 : testC , 현재 인덱스 : 2 , 현재 배열 : (3) ["testA", "testB", "testC"]

                    //첫번째 인자는 배열의 값에 접근하는 변수의 이름이다.
                    //두번째 인자는 배열의 값이 가지고 있는 인덱스 번호다.
                    //세번째 인자는 현재 접근 중인 배열이다.

                ● Arrow Function을 이용한 forEach문
                    const test = ["testA", "testB", "testC"];


                    const testArrow = (element, index, nowArray) => {
                        console.log("현재 요소 :", element, ", 현재 인덱스 :", index, ", 현재 배열 :", test);
                    };

                    test.forEach(testArrow);

                    //결과
                    //출력 1 : 현재 요소 : testA , 현재 인덱스 : 0 , 현재 배열 : (3) ["testA", "testB", "testC"]
                    //출력 2 : 현재 요소 : testB , 현재 인덱스 : 1 , 현재 배열 : (3) ["testA", "testB", "testC"]
                    //출력 3 : 현재 요소 : testC , 현재 인덱스 : 2 , 현재 배열 : (3) ["testA", "testB", "testC"]

                    //값이 자동으로 주입되서 실행된다.
            </pre>
        </span>
    </section>

    <br>

    <section id="promise">
        <span>
            <bold>promise : 약속된 값을 돌려주기 위한 문법</bold>
        </span>
        <span>▶ 기본적인 구조
            <pre>
                const promiseTest = new Promise(
                    (resolve, reject) => {
                        //resolve("success promiseTest");
                        //setTimeout(reject, 1000, "fail promiseTest");
                        //reject("fail promiseTest");
                        setTimeout(reject, 1, "fail promiseTest");
                    }
                );

                promiseTest
                    .then(value => console.log(value))
                    .catch(value => console.log(value));

                //작성 순서
                //1. new Promise()를 작성하고 ()안에 함수를 선언한다.
                //2. 첫번째 인자는 작업이 성공했을 때의 값을 돌려주는 함수다. (resolve)
                //3. 두번째 인자는 작업이 실패했을 때의 값을 돌려주는 함수다. (reject)
                //4. promise를 할당한 해당 변수에 then을 걸어서 resolve 값이 돌아오면 호출된다.
                //5. promise를 할당한 해당 변수에 catch를 걸어서 reject 값이 돌아오면 호출된다.

                //상태 값 (promise가 담겨있는 변수를 console.log로 출력했을 때)
                //1. 대기(pending): 이행하거나 거부되지 않은 초기 상태.
                //2. 이행(fulfilled): 연산이 성공적으로 완료됨.
                //3. 거부(rejected) : 연산이 실패함.

                //추가 실험
                //1. resolve가 실행되고 나면 reject는 실행되지 않는다.
                //2. 이유는 모르겠지만 reject는 resolve처럼 콘솔창에서 실행되지 않고 실행되면 소스창으로 바로 이동된다.
                //3. if문으로 reject를 실행해도 오류가 발생한다.
                //4. setTimeout을 걸면 reject도 콘솔창에서 실행된다.
            </pre>
        </span>
        <span>▶ 기본적인 예제
            <pre>
                const promiseTestWithTimer = new Promise(
                    (resolve, reject) => {
                        setTimeout(resolve, 3000, prompt("success promiseTestWithTimer"));
                    }
                );

                console.log(promiseTestWithTimer);

                setInterval(console.log, 1000, promiseTestWithTimer);

                promiseTestWithTimer.then(
                    value => console.log("now resolve return : " + value)
                );
            </pre>
        </span>
        <span>▶ Chaining Promises
            <pre>
                //기본 코드
                const chainingPromiseTest = new Promise(
                    (resolve, reject) => {
                        resolve(2);
                    }
                );

                //테스트 1
                chainingPromiseTest
                    .then(
                        value1 => console.log("now resolve value1 => " + value1) //출력 : now resolve value1 => 2
                    )
                    .then(
                        value2 => console.log("now resolve value2 => " + value2) //출력 : now resolve value2 => undefined
                    ); 

                    ※ undefined가 나오는 이유 : 연속된 then은 앞의 then에서 return되는 값을 받아야지 정상적으로 실행된다.

                //테스트 2
                chainingPromiseTest
                    .then(
                        value1 => {console.log("now resolve value1 => " + value1); return value1;} //출력 : now resolve value1 => 2
                    )
                    .then(
                        value2 => console.log("now resolve value2 => " + value2) //출력 : now resolve value2 => 2
                    );

                    ※ 첫번째 then에서 정상적으로 값을 리턴 받았기 때문에 두번째 then이 정상 작동 된다.
            </pre>
        </span>
        <span>▶ Promise.all()
            <pre>
                ●  인자로 사용되는 배열에 있는 이름들에 해당하는 모든 Promise들이 실행된 후에 최종적으로 사용되는 하나의 Promise를 반환한다.
                    예시)
                        const p1 = new Promise(
                            (resolve) => {
                                setTimeout(resolve, 5000, "First");
                            }
                        );
                        
                        const p2 = new Promise(
                            (resolve, reject) => {
                                setTimeout(resolve, 1000, "second");
                                //setTimeout(reject, 1000, "second");
                            }
                        );
                        
                        const p3 = new Promise(
                            (resolve) => {
                            setTimeout(resolve, 3000, "third");
                            }
                        );
                        
                        const allPromise = Promise.all([p1, p2, p3]);   //Promise.all() 사용법

                        allPromise
                            .then(values => console.log(values))
                            .catch(err => console.log(err)); //출력 : ["First", "second", "third"]

                        ※ Promise.all()은 내부에서 실행되는 각 Promise들이 언제 끝나든지에 상관없이 모든 Promise가 resolve 값을 반환한 후에 실행된다.
                        ※ 하나라도 reject가 발생되면 Promise.all()은 실행되지 않는다.
                        ※ Promise.all()가 반환하는 배열은 내부에서 실행된 각 Promise의 resolve 값들이 저장된다.
                           단, 값이 저장되는 순서는 종료 순서가 아닌 내부에서의 선언 순서다.
            </pre>
        </span>
        <span>▶ Promise.race()
            <pre>
                ●  인자로 사용되는 배열에 있는 이름들에 해당하는 모든 Promise들이 실행된 후에 가장 먼저 결과가 나오는 Promise의 resolve나 reject 값을 반환한다.
                    예시)
                        const p1 = new Promise(
                            (resolve) => {
                                setTimeout(resolve, 5000, "First");
                            }
                        );
                        
                        const p2 = new Promise(
                            (resolve, reject) => {
                                //setTimeout(resolve, 1000, "second");
                                setTimeout(reject, 1000, "second");
                            }
                        );
                        
                        const p3 = new Promise(
                            (resolve) => {
                            setTimeout(resolve, 3000, "third");
                            }
                        );
                        
                        const racePromise = Promise.race([p1, p2, p3]);   //Promise.race() 사용법

                        racePromise
                            .then(values => console.log(values))
                            .catch(err => console.log(err)); //출력 : second

                        ※ Promise.race()는 내부에서 실행되는 각 Promise들 중에서 가장 먼저 값을 반환하는 Promise의 resolve 값이나 reject 값을 반환한다.
            </pre>
        </span>
        <span>▶ Promise Finallizing
            <pre>
                ● 해당 Promise의 then이나 catch가 완료된 이후에 실행될 코드
                    예시)
                        const p1 = new Promise(
                            (resolve, reject) => {
                                setTimeout(resolve, 5000, "First Resolve");
                                //setTimeout(resolve, reject, "First Reject");
                            }
                        )
                            .then(value => console.log(value))
                            .catch(err => console.log(err))
                            .finally(() => console.log("First Finally"));
            </pre>
        </span>
        <span>▶ fetch()
            <pre>
                ● fetch("url") : 해당 url 주소에서 Promise를 리턴한다.
                    예시)
                        //우클릭해서 Open With Live Server로 실행 후 콘솔에 입력해서 출력 내용 확인
                        fetch("http://192.168.0.8:5500/index.html")
                            .then((response) => response.text())
                            .then((text) => console.log(text))
                            .catch((err) => console.log(`error : ${err}`)); //출력 내용은 직접 확인
            </pre>
        </span>
    </section>

    <section id="asyncAndAwait">
        <span>
            <bold>async & await</bold>
        </span>
        <span>▶ 사용 배경
            <pre>
                ● async와 await는 Promise의 업데이트다.
                ● then을 많이 쓰는 것을 지양하고, 코드를 간결하게 쓰기 위해서 사용한다.
            </pre>
        </span>
        <span>▶ 사용 방법
            <pre>
                ★ 주의점 : await는 async 함수 안에서만 사용할 수 있다.

                ● 기존 Promise의 사용 방법
                    예시)
                        const promiseBasic = () => {
                            fetch("http://192.168.0.8:5500/index.html")
                            .then((response) => response.text())
                            .then((text) => console.log(text))
                            .catch((err) => console.log(`error : ${err}`));
                        };
                    
                ● 개편된 Promise의 사용 방법
                    예시)
                        const promiseUpdate = async () => {
                            const response = await fetch("http://192.168.0.8:5500/index.html");
                            const text = response.text();
                            console.log(text);

                            //실험했더니 실패뜸
                            //const responseText = await fetch("http://192.168.0.8:5500/index.html").text();
                            //console.log(responseText);
                        };

                ※ await는 기본적으로 Promise가 끝나기를 기다린다.
            </pre>
        </span>
        <span>▶ try - catch - finally : Promise를 async와 await를 통해 사용할 때의 then과 catch
            <pre>
                const promiseUpdate = async () => {
                    try{
                        const response = await fetch("http://192.168.0.8:5500/index.html");
                        const text = response.text();
                        console.log(text);
                    }
                    catch(err){
                        err => console.log(err);
                    }
                    finally{
                        console.log("finally");
                    }
                };
            </pre>
        </span>
    </section>

    <br>

    <section id="class">
        <span>
            <bold>Class</bold>
        </span>
        <span>▶ 클래스란 무엇인가?
            <pre>
                ● 클래스 : 각 객체들에 대해서 기본적인 형태를 같게 해주기 위해 선언한 기본틀
                ● 인스턴스 : 클래스를 통해 생성한 살아있는 객체
            </pre>
        </span>
        <span>▶ 기본 사용법
            <pre>
                //클래스 생성
                class User{
                    constructor(name="temp"){
                        this.name = name;
                    }
                    sayHelloWorld(){
                        console.log("Hello World !!!");
                    }
                    test
                }

                //인스턴스 생성
                const basicUser = new User();
                let dynamicUser = new User("what");

                //콘솔에 출력
                console.log(basicUser.name);  //출력 : temp, 만약 기본값이 없다면 undefined
                console.log(dynamicUser.name);  //출력 : what

                //항목 변경
                dynamicUser.test = "test";
                console.log(dynamicUser.test);  //출력 : test

                //항목 추가
                dynamicUser.example = "example";
                console.log(dynamicUser.example);  //출력 : example, 클래스에 없는 항목이 추가된다.

                ※ 클래스를 생성할 때, var나 function를 선언하지 않아도 된다.
                ※ 클래스를 생성할 때, object를 생성하는 것과 다르게 요소들 사이에 쉼표를 쓰지 않아도 된다.
                ※ 인스턴스 생성시 기본 값들을 설정해주는 생성자는 constructor 메소드를 통해서 사용한다.
                ※ 타 언어들과 다르게 생성자는 한 개만 쓸 수 있다.
            </pre>
        </span>
        <span>▶ 상속 (extend) : 자식 클래스가 부모 클래스의 요소(변수나 메소드)를 이어 받아서 사용할 수 있도록 하는 것
            <pre>
                ● 부모가 되는 클래스 선언
                    class Parent{
                        constructor(name="who"){
                            this.name = name;
                        }
                        parentTest(){
                            console.log("This Function\'s Location is Parent");
                        }
                    }

                ● 자식이 되는 클래스 선언 (부모 클래스인 Parent를 상속)
                    class Child extends Parent{
                        constructor(age=0){
                            //super();  //name 출력시 who가 나온다.
                            super(name="whos");
                            this.age = age;
                        }
                        childTest(){
                            console.log("This Function\'s Location is Child");
                        }
                    }

                ● 상속 여부 확인
                    const whatever = new Child();

                    console.log(whatever.name);  //출력 : whos
                    console.log(whatever.age);  //출력 : 25
                    whatever.parentTest();  //출력 : This Function's Location is Parent
                    whatever.childTest();  //출력 : This Function's Location is Child

                ※ 자식 클래스의 생성자에서는 super 메소드를 선언해서 부모 클래스의 생성자가 죽지 않게 해줘야 한다.
                ※ 자식 클래스의 생성자에 있는 super를 인자를 주지 않고 사용하면
                   부모 클래스가 기존에 갖고 있던 인자들을 모두 자동으로 사용할수 있게 된다.
                ※ 자식 클래스의 생성자에 있는 super에 부모 클래스의 생성자에서 사용하는 인자와
                   같은 이름의 인자를 명시하면서 default value를 주면 해당 자식 클래스로 인스턴스 생성시 기본 값이 바뀐다.
            </pre>
        </span>
        <span>▶ 비구조화를 사용하는 클래스 생성 (object를 인자로 전달)
            <pre>
                class Test{
                    constructor({name ="who", age = 20}){
                        this.name = name;
                        this.age = age;
                    }
                    printInto(){
                        console.log(`name is ${this.name}, age is ${this.age}`);
                    }
                }

                const t1 = new Test({});    //주의
                const t2 = new Test({
                    name : "example",
                    age : 25
                });

                t1.printInto(); //출력 : name is who, age is 20
                t2.printInto(); //출력 : name is example, age is 25

                ※ 비구조화로 클래스의 생성자를 선언했을 때 기본 값으로 초기화하기 위해 인자 값을 주지 않고 인스턴스를 생성하고 싶다면
                   인스턴스를 생성할 때 new 클래스명({})로 작성해서 인자를 object로 전달한다는 기본적인 표시를 해줘야된다.
                   그렇지 않으면 에러가 발생하게 된다.
                
                ※ 이유 : object를 받아서 그 안의 항목을 받아야 되는데 ({})가 아니라 ()로 초기화를 하게 되면
                          생성자에서 사용할 항목들을 찾을 수 없기 때문에 에러가 생긴다. 
            </pre>
        </span>
    </section>

    <br>

    <section id="symbolAndSetAndMap">
        <span>
            <bold>Symbol & Set & Map</bold>
        </span>
        <span>▶ Symbol
            <pre>
                ● 심볼 (Symbol) :  새로운 데이터 타입
                ● 사용법
                    예시)
                        const hello = Symbol("test"); //new를 쓰지 않는다.   
                        const world = Symbol("test");

                        hello === wolrd //출력 : false
                        //해석 1 : "test"는 설명일뿐 심볼의 값이 아니다.
                        //해석 2 : 단순히 Symbol()을 통해 만들어낸 심볼들은 모두 다른 심볼들이다.

                        //같은 심볼을 사용하고 싶아면 Symbol.for()을 사용하면 된다.
                        const t1 = Symbol.for("test");
                        const t2 = Symbol.for("test");
                        t1 === t2 //출력 : true

                        //객체의 데이터로도 사용할수 있다.
                        const t3 = Symbol.for("test");
                        const testObj = {
                            t3 : 3,
                            [t3] : 7
                        };
                        testObj.t3  //출력 : 3, 일반적인 객체 접근 방법
                        testObj[t3] //출력 : 7, 심볼을 통한 객체 접근 방법
                ● 사용이유
                        기존에 재정의했던 메소드가 어느 순간 업데이트를 통해 표준 메소드가 되버리면 충돌이 발생할수 있기 때문에
            </pre>
        </span>
        <span>▶ Set
            <pre>
                ● Set : 중복되지 않는 유니크한 값을 가지게 해주는 생성자다.
                ● 사용법
                    예시)
                        const setTest = new Set([1,2,3,4,5,6,7,7,7]);
                        setTest //데이터를 7개만 가지고 있다고 나온다. 1에서 7까지 1개씩 가지고 있다.

                        //요소 추가
                        setTest.add(8);
                        setTest //데이터 8개 보유

                        //요소 보유 확인
                        setTest.has(8);//출력 : true

                        //요소 삭제
                        setTest.delete(8);
                        setTest //데이터 7개 보유
                
                ● 특징
                    (1) object도 저장할 수 있다.
                    (2) 작은 Database처럼 취급가능하다.
            </pre>
        </span>
        <span>▶ Weak Set
            <pre>
                ● Weak Set : object만 저장가능한 Set
                ● 사용법
                    예시)
                        const weakSetTest = new WeakSet();
                        weakSetTest.add({hi : 'hi'});
                
                ● 특징
                    (1) Set과 다르게 제한된 몇 개의 메소드만 가지고 있다.
                    (2) WeakSet 안의 object를 가리키는 무언가가 없다면 그 object는 garbage collector가 가져간다.
            </pre>
        </span>
        <span>▶ Map
            <pre>
                ● Map : key-value 방식을 통한 데이터 저장을 위한 콜렉션
                ● 사용법
                    예시)
                        const map = new Map();  //Map 선언
                        map.set("test","ttt");   //값 설정 (key-value)
                        map.has("test");        //출력 : true
                        map.get("test");        //출력 : ttt
                        map.entries();          //출력 : MapIterator {"test" => "ttt"}
            </pre>
        </span>
        <span>▶ Weak Map
            <pre>
                ● Weak Map : Map에 대해서 WeakSet처럼 사용하는 방식
            </pre>
        </span>
    </section>

    <br>

    <section id="generator">
        <span>
            <bold>제네레이터 (generator)</bold>
        </span>
        <span>▶ Generator
            <pre>
                ● 정의
                    0개 또는 1개의 값을 반환하는 일반적인 함수와 다르게 여러 개의 값을 필요에 따라 반환할수 있는 함수 선언 방식
                ● 사용법
                    예시)
                        function* testGenerator(){  //function 예약어 뒤에 *(아스타리스크)를 붙인다.
                            yield "test1";  //yield를 통해 반환한다. 일반적인 함수의 return과 동일
                            yield "test2";
                            yield "test3";
                        }

                        const resultTest = testGenerator();
                        resultTest.next();  //출력 : {value: "test1", done: false}
                        resultTest.next();  //출력 : {value: "test2", done: false}
                        resultTest.next();  //출력 : {value: "test3", done: false}
                        resultTest.next();  //출력 : {value: undefined, done: true} //반환받은 모든 리턴 값들을 모두 소모함
            </pre>
        </span>
        <span>▶ 프록시 (Proxy)
            <pre>
                ● 정의
                    사용하는 필터 객체에 따라 대상 객체에서 값을 설정하거나 가져오는 함수를 실행하게하는 객체
                ● 사용법
                    예시)
                        const testUser = {
                            name : "who",
                            age : 25 
                        };

                        const userFilter = {
                            get : (target, property, receiver) => {
                                console.log("execute get filter");  //객체의 값을 가져올시 실행
                                console.log("target :", target);    //대상이 되는 객체 자체를 나타냄
                                console.log("property :", property);  //불러지는 항목의 이름을 반환
                                console.log("receiver :", receiver);  //receiver 객체 반환
                                console.log("불러온 값 :", target[property]);  //실제 값 반환
                            },
                            set : () => {
                                console.log("execute set filter");  //객체의 값을 설정시 실행
                            }
                        };

                        const filterTestUser = new Proxy(testUser, userFilter); //new Proxy(대상 객체, 필터 객체);

                        console.log(filterTestUser.name); //출력 : execute get filter

                        filterTestUser.address = "where"; //출력 : execute set filter

                        console.log(filterTestUser);  //출력 : Proxy {name: "who", age: 25}
                ● 특징
                        Proxy를 사용하면 객체에 대한 값을 가져오거나 설정하는 것같은 행동들에 제약을 줄 수 있다.
            </pre>
        </span>
    </section>

    <br>

    <section id="es2020">
        <span>
            <bold>ES2020</bold>
        </span>
        <span>▶ ?? 연산자 : 해당 변수의 값이 null이나 undefined일 때 defualt value를 줄 수 있게 해주는 연산자
            <pre>
                ● 사용법
                    예시)
                        let name="";
                        console.log("your name is",name ?? "test");   //출력 : your name is test
                ● 사용이유
                    or 연산자(||)로도 default value를 줄 수 있긴 하다.
                    하지만 or 연산자는 논리연산자이기 때문에 만약 위의 코드에서 name의 값이 0이나 false여도 뒤의 값이 주어지게 된다.
                    name같이 이름에 대한 경우면 신경 안 쓸 수도 있겠지만, point나 score같은 경우면 문제가 될 수 있다.
            </pre>
        </span>
        <span>▶ Optional Chaining
            <pre>
                ● 사용법
                    예시)
                        const test = {name : "who"};

                        console.log(test.homeAddress.city);     //에러 발생
                        console.log(test?.homeAddress?.city);   //출력 : undefined
                        console.log(test?.homeAddress?.city ?? "Optional Chaining Test"); //출력 : Optional Chaining Test
                ● 사용이유
                    객체에서 존재하지 않는 property를 부를 때 생기는 에러를 방지
            </pre>
        </span>
        <span>▶ PadStart & PadEnd : 문자열에 padding을 집어 넣는다.
            <pre>
                ● 사용법
                    예시)
                        let seconds = 3; //10미만보다 작은 숫자는 앞에 0을 붙이고, 마지막에 초 단위를 붙이려고 함
                        seconds = String(seconds).padStart(2, "0").padEnd(3, "초"); //seconds 길이가 2보다 작으면 앞에 0 추가, 3보다 작으면 뒤에 초 단위 추가
                        console.log(seconds);   //출력 : 03초
                ● 주의사항
                    (1) padStart와 padEnd는 문자열의 함수이기 때문에 숫자인 경우에는 문자열로 형변환을 해줘야한다.
                    (2) padStart와 padEnd는 값을 바로 리턴하기 때문에 출력할 때 바로 사용하거나 아니면 따로 변수에 저장해서 사용해야 한다.
            </pre>
        </span>
        <span>▶ trim, trimStart, trimEnd : 빈 문자열 자르기
            <pre>
                ● 사용법
                    예시)
                        let testTrim = "   test trim method   ";    //앞뒤로 세칸씩 띄움
                        console.log(testTrim.trimStart());  //출력 : test trim method   , 맨앞의 빈 공간 자름
                        console.log(testTrim.trimEnd());    //출력 :    test trim method, 맨뒤의 빈 공간 자름
                        console.log(testTrim.trim());       //출력 : test trim method, 양쪽의 빈 공간 자름
                ● 주의사항
                    문자열 중간에 있는 공간들은 잘리지 않는다.
            </pre>
        </span>
        <span>▶ Object.entries(targetName), Object.values(targetName), Object.fromEntries(arrays)
            <pre>
                ● 사용법
                    예시)
                        const testObject = {name : "who", homeAddress : "where"};
                        Object.entries(testObject);     //출력 : (2) [Array(2), Array(2)], 가지고 있는 데이터를 배열로 반환한다.
                        Object.values(testObject);      //출력 : ["who", "where"], 가지고 있는 값만을 반환한다.
                        
                        const testFromEntires = Object.fromEntries([["name","lee"], ["homeAddress", "seoul"]]);   //배열을 통해서 object를 만든다. [] 안에 배열들을 나열한다.
                        testFromEntires //출력 : {name: "lee", homeAddress: "seoul"}
            </pre>
        </span>
        <span>▶ Array.Flat(n) : 깊이의 값은 n만큼 값을 추출한다.
            <pre>
                ● 사용법
                    예시)
                        const flatTest = [1, [2, 2, [7], [3, 3, [6, 4, [3, 5]], [8,9]]], [0]];

                        console.log(flatTest.flat());   //출력 : (6) [1, 2, 2, Array(1), Array(4), 0]
                        console.log(flatTest.flat(2));  //출력 : (9) [1, 2, 2, 7, 3, 3, Array(3), Array(2), 0]
                        console.log(flatTest.flat(3));  //출력 : (12) [1, 2, 2, 7, 3, 3, 6, 4, Array(2), 8, 9, 0]
            </pre>
        </span>
        <span>▶ Array.sort(compareFunction) : 배열을 정렬한다.
            <pre>
                ● 사용법
                    예시)
                        const flatTest = [1, [2, 2, [7], [3, 3, [6, 4, [3, 5]], [8,9]]], [0]];
                        const sortTest = flatTest.flat(4).sort();
                        sortTest    //출력 : (13) [0, 1, 2, 2, 3, 3, 3, 4, 5, 6, 7, 8, 9]
            </pre>
        </span>
        <span>▶ Promise.allSettled
            <pre>
                ● Promise.all()과의 차이
                    Promise.all()은 포함된 모든 Promise들 중에서 하나라도 실패하면 모두 실패지만,
                    Promise.allSttled()는 포함된 Promise들 중에서 실패한 Promise가 있어도 모든 status 값들을 반환한다.
            </pre>
        </span>
    </section>

    <div id="remote">
        <section id="remote_setcion">
            <select id="remote_menu">
                <option value="variable">변수</option>
                <option value="function">함수</option>
                <option value="string">문자열</option>
                <option value="array">배열 메소드</option>
                <option value="destructuring">비구조화</option>
                <option value="restAndSpread">Rest & Spread</option>
                <option value="forOfLoop">For of Loop</option>
                <option value="promise">Promise</option>
                <option value="asyncAndAwait">Async & Await</option>
                <option value="class">클래스</option>
                <option value="symbolAndSetAndMap">Symbol & Set & Map</option>
                <option value="generator">제네레이터</option>
                <option value="es2020">ES 2020</option>
            </select>
        </section>
    </div>
</body>
</html>