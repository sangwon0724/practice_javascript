<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES6, ES7, ...</title>
    <style>
        body {
            background-color: #eeeeee;
        }

        section {
            background-color: white;
        }

        bold {
            font-size: 25px;
            font-weight: bold;
        }

        span {
            display: block;
            margin: 10px 0;
        }

        br {
            margin: 20px 0;
        }
    </style>
</head>

<body>
    <section id="variable">
        <span>
            <bold>변수</bold>
        </span>
        <span>▶ let & const
            <pre>
                ● let : 기존의 var같은 자료형, 변수 재선언 불가, 변수 재할당 가능
                    예시 - var의 경우)
                        var str = "test";
                        var str = "example";//에러 없음
                    예시 - let의 경우)
                        let str = "test";
                        let str = "example";//에러 발생
                ● const : 변수 재선언 불가, 변수 재할당 특정 상황에 한해서 가능
                    예시 - 기본적인 변수의 경우)
                        const str = "test";
                        const str = "example";//에러 없음
                        str = "example";//에러 없음
                    예시 - 객체의 경우)
                        const str = {
                            text : "test"
                        };
                        str.name = "example";//에러 없음

                ※ 기본적인 변수는 왠만하면 const를 쓰고, 재할당할 변수만 let을 하는게 좋다.
            </pre>
        </span>
        <span>▶ Dead Zone
            <pre>
                ● 호이스팅 (Hoisting) : 자바스크립트가 프로그램을 실행하기 전에
                                       var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성
                ● var때문에 생겨나는 호이스팅의 문제점
                    예시) 만약 아래와 같은 코드가 있다고 했을 때
                          console.log(str);
                          var str = "test";
                        
                          자바스크립트는 내부에서 다음과 같이 변환한다.
                          var str;
                          console.log(str);//출력 : undefined
                          str = "test";

                          위의 코드에서는 원래 undefined가 나오면 안된다.
                          원래는 에러가 발생해야 되지만 호이스팅에 의해서 undefined가 발생한다.
                ● let과 const를 써야 하는 이유 :
                    let과 const를 쓰면 위의 코드를 똑같이 사용한다 가정했을 떄
                    이 경우에는 str은 선언하지 않은 변수라고 에러가 발생하게 된다.
            </pre>
        </span>
        <span>▶ Block Scope
            <pre>
                ● let과 const의 경우에는 블록 내부에서만 사용이 가능하다.
                    예시)
                        if(true){ let test = "test";}
                        console.log(test);  //에러 발생
                ● var의 경우에는 블록 내부/외부 상관없이 간섭이 가능하다.
                    예시)
                        if(true){ var test = "test";}
                        console.log(test);  //출력 : test;
                
                ※ 함수의 경우에는 var도 내부/외부 구분이 가능은 하지만 코딩의 실수로 간섭이 발생할수 있기 때문에
                   왠만하면 let과 const를 사용하는 것이 낫다.
            </pre>
        </span>
    </section>

    <br>

    <section id="function">
        <span>
            <bold>함수</bold>
        </span>
        <span>▶ Array.map()
            <pre>
                ● map : 각 요소를 읽는 역할을 한다.
                        인자로 넣은 함수에 각 요소들을 넣으면서 반복한다.
                        반복하면서 실행된 값들은 다시 배열에 모여서 반환된다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        function example(item){return item + "TEST";}
                        const test = somethings.map(example);//test라는 배열에 실행 값들이 저장된다.
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
            </pre>
        </span>
        <span>▶ Arrow Function
            <pre>
                ● 위와 같은 코드를 사용한다고 했을 때 ES6에 추가된 Arrow Function을 사용하면 아래처럼 바뀐다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(item => {
                            return item + "TEST";
                        });
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
                
                ● 하지만 방금의 코드는 기본적인 코드였고, 실제로는 좀 더 간단하게 줄일수 있다. (implicit return : 암시적 리턴)
                  암시적 리턴의 경우에는 {}가 없어야 실행된다. {}를 할 경우에는 undefined를 반환하기 때문에 return을 명시해줘야 한다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(item => item + "TEST");
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]

                ● 또다른 예시 (연산자가 없는 숫자나 문자열로 단순 초기화시 사용, map의 경우)
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(() => item + "TEST");
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
            </pre>
        </span>
        <span>▶ Arrow Function에서의 this
            <pre>
                ● this를 사용해야 하는 상황에서는 Arrow Function을 사용하면 안 된다.
                    예시)
                        addEventListener의 매개 변수 중 함수명을 선언하는 곳에
                        ()=>{console.log(this);}라고 작성한다면
                        현재 이 리스너가 버튼에 적용된다고 가정했을 때
                        출력은 button 태그가 아니라 window가 찍힌다.

                ● 주의점
                    리스너에서 사용할 때 ()=>{console.log(this);}라고 작성하면
                    this는 window를 가리키지만
                    function ()=>{console.log(this);}로 작성하면
                    그 때는 button 태그를 가리킨다.
                    즉, function 예약어의 유무에 따라 this가 가리키는 위치가 달라진다.

                ● 객체에 대한 Arrow Function
                    예시 1)
                        const test = {
                            name : "who",
                            age : 25,
                            addYear : () => {
                                this.age++;
                            }
                        };
                        test.addYear();
                        console.log(test.age);//출력 : 25, 이유 : this가 window를 가리킨다.
                    예시 2)
                    const test = {
                        name : "who",
                        age : 25,
                        addYear(){
                            this.age++;
                        }
                    };
                    test.addYear();
                    console.log(test.age);//출력 : 25, 이유 : this가 객체를 가리킨다.

                    ※ 즉, 객체의 메소드 내부에서 사용하는 this가
                       객체 자신을 가리키게 하고 싶다면 Arrow Function을 사용하면 안된다.
            </pre>
        </span>
        <span>▶ Arrow Function의 실제 사용법
            <pre>
                ● 이메일 찾기 (find : 첫번째 값 반환)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const foundMail = email.find(item => item.includes("@gmail.com"));
                    console.log(foundMail); //출력 : test2@gmail.com

                ● 이메일 필터 (filter : 배열 반환)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const foundMail = email.filter(item => item.includes(".com"));
                    console.log(foundMail); //출력 : ["test1@naver.com", "test2@gmail.com"]

                ● 유저명 저장 (forEach : 반복문)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    email.forEach(
                        test => { console.log(test.split("@")[0]); }
                    );
                    
                ● 유저명 저장 (map : forEach 형식으로 반환된 데이터들을 배열에 저장)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const userNames = email.map(test=>test.split("@")[0]);

                    ※ email.map((test, index) => {name : test.split("@")[0], point : index});처럼 객체로도 반환가능하다.
            </pre>
        </span>
        <span>▶ Default Value (기본 값)
            <pre>
                ● 기본적인 함수의 사용 방법
                    예시)
                        function basicFunction(text){ console.log(text);}
                        basicFunction("test message");//출력 : text message

                ● 값이 없을 경우의 임시 값을 추가하는 방법
                    예시)
                        function noneValueTestFunction(text){ console.log((text || "none value"));}
                        noneValueTestFunction();//출력 : none value

                ● Default Value를 사용하는 방법
                    예시)
                        function defaultValueFunction(text = "default value"){ console.log(text);}
                        defaultValueFunction();//출력 : default value

                ● Default Value와 Arrow Function을 함께 사용하는 방법
                    예시)
                        const defualValueAndArrowFunction = (text = "default value & arrow function") => console.log(text);
                        defualValueAndArrowFunction();//출력 : default value & arrow function
                    
                ※ Default Value는 단순한 텍스트뿐만 아니라 숫자나 변수나 객체 등 뭐든 올수 있다.
            </pre>
        </span>
    </section>

    <br>

    <section id="string">
        <span>
            <bold>문자열</bold>
        </span>
        <span>▶ Template Literal
            <pre>
                ● 기본적인 문자열 합치기
                    const test = (text = "test") => "execute " + text +" !!!";
                    console.log(test());    //출력 : execute test !!!
                    //1. 번거롭다.
                    //2. 헷갈릴 위험도 크다.

                ● 백틱과 함께 쓰기 - 기본편 (` : 물결표랑 같이 있는 기호)
                    const test = (text = "test") => `execute ${text} !!!`;
                    console.log(test());    //출력 : execute test !!!

                ● 백틱과 함께 쓰기 - 응용편 (함수 사용)
                    const add = (a, b) => a + b;
                    const test = (text = "test") => `execute ${add(1, 6)} !!!`;
                    console.log(test());    //출력 : execute 7 !!!
            </pre>
        </span>
        <span>▶ HTML 태그 & Template Literal
            <pre>
                ● 사용법
                    const testDiv = document.getElementById("testDiv");
                    const span = `&lt;span>This is HTML Tag + Template Literal !!!&lt;/span>`;
                    testDiv.innerHTML = span;

                ● 응용법
                    const testArray = ["a", "b", "c"];
                    const testDiv = document.getElementById("testDiv");
                    const list =
                    `&lt;ul>${testArray.map(test => `&lt;li>${test} ★&lt;/li>`).join("")}&lt;/ul>`;
                    testDiv.innerHTML = list;
                
                ※ 백틱(`)은 엔터를 입력하면 엔터도 적용을 시켜준다. ===> &lt;br>을 사용할 필요가 없어진다.
            </pre>
        </span>
        <span>▶ Style을 적용시킨 노드 만들기
            <pre>
                ● css를 적용시킨 태그를 반환하는 방법
                    예시)
                        const settingStyle = newElement =>{
                            const newEle = document.createElement(newElement);//신규 태그 생성

                            return args = (text ="test text", styleArray) => {
                                const settingStyleOptions = styleArray;  //css로 적용할 값들을 불러와서 저장
                                newEle.style = settingStyleOptions;   //태그에 css 적용
                                newEle.innerHTML = text;
                                return newEle;  //태그 반환
                            };
                        };

                        const title = settingStyle("h1")("hmm",`
                            color : white;
                            background-color : blue;
                            font-weight : bold;
                        `);
                        //해설
                        //1. settingStyle에 "h1"이라는 인자를 넣어서 실행한다.
                        //2. 실행될 함수에 한번더 인자를 주게되면 return에서 실행되는 함수에 인자를 준다.

                        document.getElementById("testDiv").append(title);//스타일을 적용시킨 h1 태그를 추가
                
                ● 위의 다중 함수 실행에 대한 테스트
                        예시)
                            const add1 = (a = 0, b = 0) => {
                                console.log(`add 1 : ${a} + ${b} = ${a+b}`);
                                return add2 = (c = 0, d = 0) =>{
                                    console.log(`add 2 : ${c} + ${d} = ${c+d}`);
                                    return add3 = (e, f = 0) =>{
                                        console.log(`add 3 : ${e} + ${f} = ${e+f}`);
                                    }
                                }
                            };

                            add1(1,1)(2,2)(3,3);
                            //출력 목록
                            //add 1 : 1 + 1 = 2
                            //add 2 : 2 + 2 = 4
                            //add 3 : 3 + 3 = 6
            </pre>
        </span>
        <span>▶ 백틱에 의한 함수 호출 방법
            <pre>
                ● 기본편
                    예시)
                        위의 add1를 실행할때
                        add1`1`,(2,2)(3,3);로 실행해도 된다.
                        대신 이 경우에는 1이 숫자가 아닌 문자열이니 이 부분은 조심해야 한다.
                        //출력 목록
                        //add 1 : 1 + 0 = 10
                        //add 2 : 2 + 2 = 4
                        //add 3 : 3 + 3 = 6

                ● 응용편
                    예시)
                        const test = {
                            first : "first",
                            second : "second"
                        };

                        function amazing(strings, var1, var2){
                            //인자를 꼬아서 strings를 맨뒤로 보내보면 인자를 어떻게 받는지 알수있다.
                            console.log(strings);
                            console.log(var1);
                            console.log(var2);
                            return `${strings[0]}${var1}${strings[1]}${var2}${strings[2]}`;
                        }

                        console.log(amazing`시작-${test.first}-중간-${test.second}-끝`);//출력 : 시작-first-중간-second-끝

                        //해설
                        //백틱을 사용해서 실행하게 되는 함수는 첫번째 인자에
                        //백틱에서 사용되었던 ${}를 제외한 문자열들이 배열로 저장되게 된다.
                        //첫번째 인자 이후의 인자들은 ${}로 사용한 인자들이 차례대로 저장된다. 
            </pre>
        </span>
    </section>
    <span>▶ 추가적인 문자열 메소드들
        <pre>
            ● include("찾을 문자열") : 해당 문자열이 존재하는가 검색
            ● "문자열".repeat(n) : n번만큼 문자열을 반복
            ● "문자열".startsWith("찾을 문자열") : 해당 문자열로 시작되는지 확인
            ● "문자열".endsWith("찾을 문자열") : 해당 문자열로 종료되는지 확인
        </pre>
    </span>
</section>

    <!-- 테스트용 -->
    <div class="" id="testDiv"></div>
</body>

</html>