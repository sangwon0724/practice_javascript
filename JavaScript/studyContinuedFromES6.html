<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES6, ES7, ...</title>
    <style>
        body {
            background-color: #eeeeee;
        }

        section {
            background-color: white;
        }

        bold {
            font-size: 25px;
            font-weight: bold;
        }

        span {
            display: block;
            margin: 10px 0;
        }

        br {
            margin: 20px 0;
        }
    </style>
</head>

<body>
    <section id="variable">
        <span>
            <bold>변수</bold>
        </span>
        <span>▶ let & const
            <pre>
                ● let : 기존의 var같은 자료형, 변수 재선언 불가, 변수 재할당 가능
                    예시 - var의 경우)
                        var str = "test";
                        var str = "example";//에러 없음
                    예시 - let의 경우)
                        let str = "test";
                        let str = "example";//에러 발생
                ● const : 변수 재선언 불가, 변수 재할당 특정 상황에 한해서 가능
                    예시 - 기본적인 변수의 경우)
                        const str = "test";
                        const str = "example";//에러 없음
                        str = "example";//에러 없음
                    예시 - 객체의 경우)
                        const str = {
                            text : "test"
                        };
                        str.name = "example";//에러 없음

                ※ 기본적인 변수는 왠만하면 const를 쓰고, 재할당할 변수만 let을 하는게 좋다.
            </pre>
        </span>
        <span>▶ Dead Zone
            <pre>
                ● 호이스팅 (Hoisting) : 자바스크립트가 프로그램을 실행하기 전에
                                       var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성
                ● var때문에 생겨나는 호이스팅의 문제점
                    예시) 만약 아래와 같은 코드가 있다고 했을 때
                          console.log(str);
                          var str = "test";
                        
                          자바스크립트는 내부에서 다음과 같이 변환한다.
                          var str;
                          console.log(str);//출력 : undefined
                          str = "test";

                          위의 코드에서는 원래 undefined가 나오면 안된다.
                          원래는 에러가 발생해야 되지만 호이스팅에 의해서 undefined가 발생한다.
                ● let과 const를 써야 하는 이유 :
                    let과 const를 쓰면 위의 코드를 똑같이 사용한다 가정했을 떄
                    이 경우에는 str은 선언하지 않은 변수라고 에러가 발생하게 된다.
            </pre>
        </span>
        <span>▶ Block Scope
            <pre>
                ● let과 const의 경우에는 블록 내부에서만 사용이 가능하다.
                    예시)
                        if(true){ let test = "test";}
                        console.log(test);  //에러 발생
                ● var의 경우에는 블록 내부/외부 상관없이 간섭이 가능하다.
                    예시)
                        if(true){ var test = "test";}
                        console.log(test);  //출력 : test;
                
                ※ 함수의 경우에는 var도 내부/외부 구분이 가능은 하지만 코딩의 실수로 간섭이 발생할수 있기 때문에
                   왠만하면 let과 const를 사용하는 것이 낫다.
            </pre>
        </span>
    </section>

    <br>

    <section id="function">
        <span>
            <bold>함수</bold>
        </span>
        <span>▶ Array.map()
            <pre>
                ● map : 각 요소를 읽는 역할을 한다.
                        인자로 넣은 함수에 각 요소들을 넣으면서 반복한다.
                        반복하면서 실행된 값들은 다시 배열에 모여서 반환된다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        function example(item){return item + "TEST";}
                        const test = somethings.map(example);//test라는 배열에 실행 값들이 저장된다.
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
            </pre>
        </span>
        <span>▶ Arrow Function
            <pre>
                ● 위와 같은 코드를 사용한다고 했을 때 ES6에 추가된 Arrow Function을 사용하면 아래처럼 바뀐다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(item => {
                            return item + "TEST";
                        });
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
                
                ● 하지만 방금의 코드는 기본적인 코드였고, 실제로는 좀 더 간단하게 줄일수 있다. (implicit return : 암시적 리턴)
                  암시적 리턴의 경우에는 {}가 없어야 실행된다. {}를 할 경우에는 undefined를 반환하기 때문에 return을 명시해줘야 한다.
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(item => item + "TEST");
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
                ● 또다른 예시 (연산자가 없는 숫자나 문자열로 단순 초기화시 사용, map의 경우)
                    예시)
                        const somethings = ['a', 'b', 'c'];
                        const test = somethings.map(() => item + "TEST");
                        console.log(test);//출력 : ["aTEST", "bTEST", "cTEST"]
            </pre>
        </span>
        <span>▶ Arrow Function에서의 this
            <pre>
                ● this를 사용해야 하는 상황에서는 Arrow Function을 사용하면 안 된다.
                    예시)
                        addEventListener의 매개 변수 중 함수명을 선언하는 곳에
                        ()=>{console.log(this);}라고 작성한다면
                        현재 이 리스너가 버튼에 적용된다고 가정했을 때
                        출력은 button 태그가 아니라 window가 찍힌다.
                ● 주의점
                    리스너에서 사용할 때 ()=>{console.log(this);}라고 작성하면
                    this는 window를 가리키지만
                    function ()=>{console.log(this);}로 작성하면
                    그 때는 button 태그를 가리킨다.
                    즉, function 예약어의 유무에 따라 this가 가리키는 위치가 달라진다.
                ● 객체에 대한 Arrow Function
                    예시 1)
                        const test = {
                            name : "who",
                            age : 25,
                            addYear : () => {
                                this.age++;
                            }
                        };
                        test.addYear();
                        console.log(test.age);//출력 : 25, 이유 : this가 window를 가리킨다.
                    예시 2)
                    const test = {
                        name : "who",
                        age : 25,
                        addYear(){
                            this.age++;
                        }
                    };
                    test.addYear();
                    console.log(test.age);//출력 : 25, 이유 : this가 객체를 가리킨다.

                    ※ 즉, 객체의 메소드 내부에서 사용하는 this가
                       객체 자신을 가리키게 하고 싶다면 Arrow Function을 사용하면 안된다.
            </pre>
        </span>
        <span>▶ Arrow Function의 실제 사용법
            <pre>
                ● 이메일 찾기 (find : 첫번째 값 반환)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const foundMail = email.find(item => item.includes("@gmail.com"));
                    console.log(foundMail); //출력 : test2@gmail.com
                ● 이메일 필터 (filter : 배열 반환)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const foundMail = email.filter(item => item.includes(".com"));
                    console.log(foundMail); //출력 : ["test1@naver.com", "test2@gmail.com"]
                ● 유저명 저장 (forEach : 반복문)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    email.forEach(
                        test => { console.log(test.split("@")[0]); }
                    );
                ● 유저명 저장 (map : forEach 형식으로 반환된 데이터들을 배열에 저장)
                    const email = ["test1@naver.com", "test2@gmail.com", "test3@hanmil.net"];
                    const userNames = email.map(test=>test.split("@")[0]);

                    ※ email.map((test, index) => {name : test.split("@")[0], point : index});처럼 객체로도 반환가능하다.
            </pre>
        </span>
        <span>▶ Default Value (기본 값)
            <pre>
                ● 기본적인 함수의 사용 방법
                    예시)
                        function basicFunction(text){ console.log(text);}
                        basicFunction("test message");//출력 : text message
                ● 값이 없을 경우의 임시 값을 추가하는 방법
                    예시)
                        function noneValueTestFunction(text){ console.log((text || "none value"));}
                        noneValueTestFunction();//출력 : none value
                ● Default Value를 사용하는 방법
                    예시)
                        function defaultValueFunction(text = "default value"){ console.log(text);}
                        defaultValueFunction();//출력 : default value
                ● Default Value와 Arrow Function을 함께 사용하는 방법
                    예시)
                        const defualValueAndArrowFunction = (text = "default value & arrow function") => console.log(text);
                        defualValueAndArrowFunction();//출력 : default value & arrow function
                    
                ※ Default Value는 단순한 텍스트뿐만 아니라 숫자나 변수나 객체 등 뭐든 올수 있다.
            </pre>
        </span>
    </section>
</body>

</html>